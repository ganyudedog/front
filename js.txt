任何能执行代码的设备,都称之为计算机。

计算机语言指人与计算机通讯的语言,是人与计算机之间传递信息的媒介。
计算机语言总的来说可以分为机器语言,汇编语言和高级语言三大类。

机器语言就是计算机所执行的语言,由一堆二进制数所构成,二进制是计算机语言的基础。

编程语言就是通过类似于人的语言来让计算机为我们做事情。
通用的编程语言有两种形式: 汇编语言和高级语言。

汇编语言和机器语言的实质相同,是直接对硬件操作,但指令采用了英文缩写的标识符,容易识别和记忆。
而高级语言就是我们主要所说的编程语言,像c , c++ , javascript等。

高级语言所编写的程序不能被计算机直接识别,必须经过转换才能执行,因此,就出现了翻译器,它能够将高级语言转换为机器语言。
翻译器翻译的方式有两种: 解释和编译。两种方式的区别在于翻译的时间点不同。
编译是在代码执行前编译,生成中间代码文件(c++,java属于编译型);解释是在运行时进行及时解释,并立即执行(js就属于解释型)。

编程语言有很强的逻辑和行为能力,是主动的。
而标记语言不用向计算机发出指令,常用于格式化和链接,标记语言的存在是用来被读取的,是被动的。

计算机分为硬件和软件:
1.硬件分为5大部分
(1)输入设备: 鼠标,键盘,手写板,摄像头等
(2)输出设备: 显示器,打印机,投影仪等
(3)cpu: 负责处理数据和运算
(4)磁盘: 永久存储数据
(5)内存: 临时存储数据

2.软件分为2大部分
(1)系统软件: windows,linux,macOS
(2)应用软件: 浏览器,QQ等

所有数据都是以二进制的形式存放在硬盘中的。

程序的运行: 打开某个程序时,程序的代码会先从硬盘中被加载到内存中,cpu再执行内存中的代码,
注意:之所以需要内存,是因为cpu运行太快了,如果只从硬盘中读取数据,会浪费cpu的性能,所以,才使用存取速度更快的内存来保存运行时的数据(内存是电,硬盘是机械)。


数据结构(重要!!!)
简单类型和复杂类型
简单类型又叫做 基本数据类型 / 值类型 , 复杂类型又叫做引用类型。

简单类型: 在存储时存储的是值本身。
复杂类型: 在存储变量时仅仅存储的时地址(引用)。

系统会把内存空间分为两个部分: 栈 和 堆。(实际上js没有堆栈的概念,只是为了易于理解)
栈: 由操作系统自动分配的存放函数的参数值,局部变量的值,复杂类型的地址(c++的数组名为地址的原因)等,操作方式和c++中的一样,简单数据类型放到栈中。
堆: 存储复杂类型(对象),一般由程序员分配释放,若程序员不释放,则由垃圾回收机制回收。

简单数据类型的传参(值传递)
由于简单数据类型和函数的参数存放在栈中,当调用函数时,函数中的参数改变了,但是实参由于和参数不在一个地方,所以实参不变。

复杂数据类型的传参(地址传递)
由于复杂数据类型的地址存放在栈中,当调用函数时,该地址指向的值变了,所以实参变了。

--------------------------------------------------------

js是一种运行在客户端的脚本语言(script就是脚本的意思)
脚本语言: 不需要编译,运行时有js解释器(js引擎)逐行来进行解释并执行。
现在也可以基于Node.js技术对服务器端进行编程。

js作用:
1.表单动态校验(密码强度检测)
2.网页特效
3.服务端开发(Node.js)
4.桌面程序(Electron)
5.App(Cordova)
6.控制硬件-物联网(Ruff)
6.游戏开发(coco2d-js)

浏览器分为两部分: 渲染引擎和js引擎。
渲染引擎: 用来解析html和css,俗称内核,如webkit,blink等。
js引擎: 也叫js解释器,用来读取web中的js代码,对其处理后运行,如chrome的V8。
注意: 浏览器本身并不会去执行js代码,而是通过内置的js引擎来执行js代码,js引擎执行代码时会逐行转化为机器语言,然后由计算机去执行。

js由三部分组成: ECMAScript(js语法), DOM(页面文档对象模型), BOM(浏览器对象模型)。
DOM是处理可扩展标记语言的标准编程接口,通过DOM提供的接口可以对页面上的各种元素进行操作(大小,位置,颜色等)
BOM提供了独立于内容的,可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口,比如弹出框,控制浏览器跳转,获取分辨率等。

注意: 在html中推荐使用双引号,而在js中我们推荐使用单引号。

js中的注释和css中的注释差不多,单行注释都是 ctrl + / 

-----------------------------------------------------------------------
js文件的书写方式(和之前的css差不多):
1.行内
直接写到元素的内部
如点击弹出一些东西: <button onclick="alert('md')">???</botton>
这时点击这个按钮即会弹出alert里面的内容。
注意: 外面用了双引号以后,里面就只能用单引号。同理,外面用了单引号后,里面只能用双引号。 

2.内嵌
写在<script></script>中,和之前的css差不多。

3.外部引入
将js单独写到一个文件中,再将其引入到html中。
语法规范:<script src="路径"></script> 
注意: 一旦从外部引入,则<script></script>里面就不能写代码了。

制作轮播图时,由于js代码实现较为复制,可以使用swiper插件,下载地址: https://www.swiper.com.cn/
这个插件可以提供需要的css和js文件,甚至还有与你所想相似的html架构。

-------------------------------------------------------------------
下面为js的基本语法

js中每一句语言用 ; 隔开。

alert('')表示提醒,在web中作为显示的警示页面,点击确定后才会继续显示web的内容(引号里面为警示的内容,引号不可省),类似于printf(),但输出变量时只需要变量名即可。

console.log('') 表示浏览器控制台打印输出的信息(只有在检查里面的控制台才能看到,一般是程序员看的),类似于printf()的改版,但输出变量时只需要变量名即可。
也可以输出 12 + 12 这样的计算表达式,最终会把结果输出。
由于这样每输出一次都会换行,所以需要用字符串叠加的方式才能来输出一个字符串。
当程序错误时,其会提示出错的行数。

prompt('') 表示浏览器弹出输入框,用户可以输入,其所获取的变量的类型为string型,类似于scanf()。

在浏览器中,可以通过检查中的source来设置程序断点,进而调试(可以控制循环进行的次数)。

和c++一样,js中也有变量,本质差不多一样,为一块存放数据的内存空间。
使用变量时也和c++差不多,先声明,再赋值。

js书写规范: 操作符左右两侧需留出一个空格,for里面的小括号左右两侧要留出一个空格。

var a; 这样就声明一个叫做a的变量(定义多个变量也和c++差不多)。
赋值方式也和c++差不多。
注意: 这样声明的变量所赋的值可以为字符串,数字等(若赋值类型为字符串,需加引号,单双都可,一般为单)

var a = b = c = 9;这句话相当于var a = 9; b = 9; c = 9;(重要!!!)

变量的输入方式为 变量名 = prompt('提示信息');这样变量才能正确赋值,不能直接将变量写到prompt()中。 
但可以直接输出alert(变量名)。

若只声明,不赋值,输出时则会输出undefined;若不声明,不赋值,输出时会报错;若不声明,只赋值,则会输出相应的值(这样的话,这个会变成全局变量,不推荐使用)。

变量的命名遵守驼峰命名法,即第一个单词的首字母小写,后面的单词首字母大写,其他的和c++差不多。
注意: 变量,函数的命名必须要有意义,变量的名称一般用名词,函数的名称一般用动词。

注意: js中可以阻止链接跳转,需要在a的href中将值设为 javascript:void(0); 或 javascript:; ,这样就可以阻止链接的跳转。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

warning(重要!!!): js中字符串里面的值不可变,修改时看上去是变了,实际上是变量名指向的地址变了,内存中开辟了一个新的空间。
所以,不要大量声明字符串和拼接字符串。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


数据类型
js是一种弱类型的语言,也可以叫动态语言,不需要声明变量的类型,在程序运行时,类型会自动确定。
在js中数据类型可以随着赋值的变化而变成不同的数据类型。

js将数据类型分为两大类: 简单数据类型(number,string,bool,undefined,null) , 复杂数据类型(object) 。

简单数据类型中的number包含了浮点数和整形。
js中数字前面加上0就表示8进制。
js中数字的前面加0x表示16进制。
js中数字的最大值是Number.MAX_VALUE(一个变量名),为17的308次方,所以无需高精度。
js中数字的最小值是Number.MIN_VALUE(同上),为50的-324次方。
在js中number还有三个特殊值 Infinity(无穷大), -Infinity(无穷小), NaN(not a number,非数值) 。

isNaN()这个用来判断是否为非数字,是,返回true ; 不是,返回false。


简单数据类型中的string,可以是引号中的任意文本,引号可以为单引号和双引号,在js中一般推荐使用单引号。
在js中的字符串中可以引号嵌套,但是外双里单,外单里双。
在js的字符串类型中也有转义字符: \n(换行) , \\(表示\) , \'(表示') , \"(表示") , \t(tab缩进) , \b(空格) 。
注意: 转义字符要写到引号里面。

通过字符串的length属性可以获取整个字符串的长度(字符串中的空格也计入长度!!!)。
若想输出字符串的长度,则只需要在相应的变量后面加上.length即可
如var str='1264'; console.log(str.length);即可输出str的长度。

字符串的拼接: 字符串 + 任意类型的变量
无论任意类型的变量是什么,最终都会变成字符串类型的变量,把变量拼接到字符串之后。
在 + 号中,数值相加,字符相连。
在输出的字符串要包含变量时,是通过字符串相连的方式实现的。


简单数据类型的bool型,只有两个值: true和false 。
和c++一样,当bool值运算时true为1,false为0。


简单数据类型中的undefined和null。
undefined是一个变量声明后没有赋值的默认值,在与字符串相连时也时undefined与字符串相连。
当undefined和一个数字相加时,结果为NaN。

null表示空值,返回的是一个空对象!!!和字符串相连时与undefined一样。
但当它和数字相加时,由于null为空值,相当于0,所以与数字相加时结果为数字本身。
如果需要创建一个还没有想好的对象,就可以使用null。

在控制台中,不同数据类型输出时的颜色时不一样的(只有undefined和null相同)。


typeof可以用来检测变量(包括object)的具体类型。
语法规范: typeof 要检测的变量;使用console.log输出即可。console.log(typeof 要检测的变量);

数据类型转换: 将一种数据类型转换为另一种数据类型。
1.转换成字符串
(1)tostring()   方式:需要转换的变量名.tostring()
(2)String()强制转换   方式:String(需要转换的变量名)
(3)加号拼接空字符串   方式:变量 + ''   这种方式并不会直接转换,开发中常用一些。

2.转换成数字型
(1)parseInt(string) 将string转换为整数数值型 方法: parseInt(string) 
(2)parseFloat 将string转换为浮点数数值型 方法: parseFloat(string)
注意: 上面两个方法字符串的开头必须是数字,否则无效,且当它检测非数字后,会把当前非数字和后面的所有全部删掉。
还要注意其大小写。

(3)Number()强制转换 将string转换为数值型 方法: Number(string)

(4)js隐式转换(- , * , /) 利用算术运算转换 方法: '12' - 0 (字符型的数字相减也会转换为数字型)
注意: 隐式转换为数字型时,字符串后面不能有非数字。

3.转换为bool型
Boolean 将其他类型转换为bool型 方法: Boolean(要转换的值)
注意: 只有代表空,否定的值会被转换为false,如'',NaN,null,undefined,其他的都为true。


js的运算符
注意: 运算符左右都要有一个空格。
基础运算符同c++,取余都是%,还有+=,-=等,先后顺序和概念也同c++。

在js中也有和c++中一样的自增自减表达,且一定要和变量搭配一起使用(放在变量前后也和c++一样)。
注意: 当自增自减式子执行完以后就会变量就改变了。

但直接用浮点数进行运算会出现问题,所以在计算中不要直接使用浮点数进行运算(0.1 + 0.2 != 0.3)。

表达式: 由数字,运算符,变量等组成的式子,称为表达式。
所有的表达式都有一个返回值,和c++一样。

比较运算符相较于c++还多了一个!==,===。
!==表示不全等,只要数据类型和值有一个不同就为真。
===表示全等,数据类型和值全部相同才为真。
注意: js中的逻辑运算符会将两边的数据类型自动转化为相同的。

逻辑运算符和c++一样。
逻辑运算中存在短路运算(也叫逻辑中断): 当有多个表达式时,左边的表达式值可以确定结果时,就不会在计算右边表达式的值!!!
注意: && 的运算优先级高于 || 。

&&中的短路运算
语法规范: 表达式1 && 表达式2;
如果第1个表达式为真,则返回表达式2;如果第1个表达式为假,则返回表达式1。

||中的短路运算
语法规范: 表达式1 || 表达式2;
如果第1个表达式为真,则返回表达式1;如果第1个表达式为假,则返回表达式2。

如果碰到连续短路运算,则需要按照计算顺序依次计算。
如123 || 456 || 789,123为真,则计算顺序为(123 || 456) || 789 。


js中的分支结构,流程控制
流程控制就是来控制代码按什么顺序来执行。

和c++一样,都依赖于if和switch。
if和switch的用法和c++一致。
js中还有c++中的三元运算符 ?:  。

if-else用于范围的判断,而switch则主要用于具体值的判断(switch的效率更高)。


js中的循环结构,用法和c++基本一致(for, while , do-while)。

for循环写法: for(var i=1;i<=100;++i)
只有定义符号变了。
注意: 当浏览器一直在加载时很有可能是写循环时进入了死循环(字符串卡死是因为数据量过大,大概率不会是字符串的情况)!!!

js中也存在continue和break,用法和c++一样。

js中的数组
js中创建数组有两种方式:
1. 利用new来创建数组
语法规范: var 数组名 = new Array();

2. 通过数组字面量来创建数组
语法规范: var 数组名 = [];
注意: 这里的数组里面可以放任意类型的元素,且元素之间的类型可以不同!!!
[]为数组中的元素,元素之间用 , 隔开。

若直接输出数组名,则会输出该数组中的所有元素和它们对应的索引号。

注意: 不要给数组名赋值,否则里面的数组元素都会消失。

js获取数组元素的方式和c++一样,且下标都是从0开始。
当js中出现数组越界或者元素不存在时,会输出undefined。

js中可以通过 数组名.length 表示数组元素的数量(数组长度),为实时监测,只要数组长度出现变化就立刻改变。

数组新增元素:
1. 直接修改length长度
语法规范: 数组名.length = 增加后的长度;
这样数组就被修改了且原来的不动,多出来的位置的数据类型为undefined。 

2. 修改索引号(下标),
语法规范: var a=[]; a[1]=1;
这样数组a中追加了一个数组元素(非常方便!!!)。

js中还具有伪数组,伪数组具有以下特点:
1. 具有 length 属性。
2. 按照索引的方式存储数据。
3. 但没有真数组的一些方法,如pop(),push()等。


js中的函数
封装了一段可以被重复调用执行的代码块,称之为函数。

函数的使用:
1.声明函数(有两种声明方式)
(1)利用function(命名函数)
语法规范: function 函数名(形参1 , 形参2, ...){}
函数是做某件事情,所以函数名一般为动词。
这里的形参可以看作一个定义了的变量,所以不需要var,直接写形参名即可。
若实参为数组,形参也就自动变为了数组,所以无需改动。
注意: 函数不调用,自己不执行;且js中的函数不要求有返回值。

(2)变量名赋予函数表达式(匿名函数)
语法规范: var 变量名 = function(形参1 , 形参2, ...){}
这两个函数的调用方法一致。

函数中可以嵌套声明函数,但需要注意作用域的问题。

2.调用函数
和c++一样,但这里的函数可以调用另外的函数,且函数的先后顺序不会影响调用。
调用函数时()里面的值叫实参。

注意: js中的函数并不要求实参和形参必须匹配,当实参多余形参时,多余实参不参与;当实参的个数小于形参,则没有接受值的形参为undefined。

在js中,return表示将函数计算出来需要返回的值返回给调用者。
语法规范: return 需要返回的值;
同样,当函数执行到return时,后面的代码就不会执行了。
若函数没有return,则返回值undefined。
注意: return只能返回一个值(返回一个式子也可以),若有多个,则会返回最后一个,若想返回多个值,就需要以数组的形式返回(return [a,b];)。

arguments(只有函数才有)的使用
当不确定有多少个参数传递时,可以使用arguments来获取,在js中,arguments实际上是当前函数的一个内置对象(所有函数都有),arguments存储了传递的所有实参。
arguments实际上是一个伪数组。

函数中还有this这个指针,指向的是事件的调用者,若要修改对象的属性,就可以通过this.相应的属性名 = 要修改的属性 。

js的作用域
一段程序所用的名字并不总是有效和可用的,该名字可用的代码范围就是这个名字的作用域。
es6之前有两种作用域:
1. 全局作用域(整个script标签或者一个外部的js文件)
2. 局部作用域(函数就是局部作用域,只在函数内部起作用)

由作用域的不同,变量可以分为两种: 全局变量和局部变量。
全局变量(注意不声明只赋值的情况)作用于全局,局部变量(形参也是局部变量)只作用于函数内部。
注意: 全局变量只有在浏览器关闭的时候才会消失,比较占内存;而局部变量在程序执行完以后就会消失。

js在es6之前没有块级作用域,es6就有了。

由内部函数可以访问外部函数变量的机制,用链式查找决定哪些数据能被内部函数访问,就称之为作用域链。
作用域链采用的原则为就近原则,哪个离函数近,就采取哪个,若上一层没有,则再往更上一层找。


js中的预解析(重要!!!)
js解析器在解析js代码时分两步: 预解析和代码执行。

预解析: js引擎会把js里面所有的var和function提升到当前作用域的最前面。
预解析分为 变量预解析(变量提升) 和 函数预解析(函数提升)。
1. 变量提升
把所有的变量声明提升到当前作用域前面。
注意: 只提升了变量声明,不提升赋值操作。

2. 函数提升
将所有的函数声明提升到当前作用域的前面。

代码执行: 按照代码书写的顺序从上往下执行。


js对象
在js中,对象是一组无序的相关属性和方法的集合,所有的具体事物都是对象,可以使表达的结构更为清晰。
所以对象是由属性和方法组成的。
属性: 事物的特征。      方法: 事物的行为。

创建对象共有三种方式:
1.利用字面量来创建对象
语法规范: var 变量名 = {对象的信息(包含属性和方法)}
属性的写法: 属性名: 值,
方法的写法: 方法名: function(){}
注意: 每个信息之间用 , 隔开,最后一个信息可以不跟 , 。

2.利用new Object创建对象
语法规范: var 变量名 = new Object();
若想追加信息,则在下面单独书写。
变量名.信息 = 代码;
注意: 这时每个信息之间用 ; 隔开。

3.利用构造函数创建对象(构造函数首字母要大写,这是规范)
这种方法一次可以创建多个对象,前面的一次只能创建一个,构造函数实际上就是一大类(同c++的class)。
语法规范: function 构造函数名(形参1 , 形参2, ...) {
    this.属性 = 值;
    this.方法 = function (形参) {}
}
调用该函数的方法也不同: var 变量名 = new 构造函数名(实参1, 实参2, ...);
注意: 使用这种方法时,构造函数的返回值要赋予一个变量(构造函数不需要return)。

对象的实例化就是利用构造函数创建对象。

new在调用构造函数是的作用
new 构造函数(实参) 就是在内存中创建了一个空对象,而构造函数中的this就会指向这个对象(同指针),然后就会执行构造函数里面得的代码,最后返回。


对象的使用
调用对象的属性有两种方法
(1) 对象名.属性名           (2)对象名['属性名'](引号不能省)

调用对象的方法: 对象名.方法名()   。 

对象的遍历
for...in 语句可以用于对数组或对象的属性进行循环操作!!!
语法规范: for(变量 in 对象)
for(var k in 对象名) console.log(k);这样即可输出对象的所有信息名。
for(var k in 对象名) console.log(对象名[k]);这样即可输出对象的所有信息值。
这里的k不加引号!!!


js的内置对象
js中对象分三种: 自定义对象, 内置对象, 浏览器对象。
前两种对象是js的基础内容,属于es;浏览器对象为js特有的。

内置对象就是js语言自带的一些对象,这些对象供开发者使用,并提供了常用的或是最基本而必要的一些功能。
js中的内置对象: Math,Date,Array,String等。

Math对象(非构造函数,不需要new)
Math.PI表示圆周率,Math.max()表示求最大值(若给的数值中有至少一个为非数字类型的,则返回NaN;若小括号为空,则返回-Infinity)。
Math.abs()表示求绝对值(这里存在隐式转换,会把字符型的数字转换为数字型)。
Math.floor()表示向下取整,Math.ceil()表示向上取整,Math.round()则表示四舍五入就近取整,但如果小数部分为 .5 的话往大了取(-3.5 的结果为 -3)。

Math.random()表示返回一个随机浮点数,范围为[0,1),()里面不跟参数。
若想使它取整数且在一个范围之内,需要用到上面的取整,通过数学方式来实现。
Math.floor(Math.random() * (max - min + 1)) + min 取值范围即为[min,max]。
注意: 若使用ceil,则min的概率很小很小,所以不使用ceil。

Date对象
Date是一个构造函数,故调用时要使用new来调用。
如果Date()中的()没有输入任何的参数,则Date的构造器会依据系统设置的时间来创建一个Date对象。
()内参数常用的写法: 数字型 2010, 10, 1 或者是 字符串型 '2010-10-1 8:8;8'
注意: 使用数字型时,输出的月份会比输入的月份大一个月,字符串型则没有这种问题。

getFullYear()表示返回对象的年份;getMonth()表示当前的月份,但由于是从0开始,所以返回的月份会比当前的月份小一个月。
getDate()表示返回对象的日期;getDay()表示当前是星期几(周日返回的是0,若想中文化,可以使用数组来显示)
同理getHours(),getMinutes(),getSeconds()分别返回小时,分钟,秒。

Date对象是基于1970.1.1起的毫秒数。
若想获得当前距离1970.1.1过了多少毫秒数(也叫时间戳,可以用于加密),有两种方法:
1. 通过 valueOf()
语法规范: Date对象名.valueOf()

2.通过 getTime()
语法规范: 同上

3.通过 +new Date() (常用!!!)
语法规范: var 变量名 = +new Date();
若括号为空,则返回当前时间距离1970.1.1的毫秒数;若不为空,则返回括号中时间距离1970.1.1的毫秒数。
这样变量即为上述的毫秒数。

4.通过 Date.now() (H5新增的)
语法规范: console.log(Date.now());
直接输出即可。

倒计时核心: 输入的时间减去当前的时间,但不能直接减,故采用时间戳来做,减去以后再转换为年月日时分秒。

时间戳计算的小时数和正常时间差8小时是因为时区的问题,所以尽量使用getHours(),这个会自动判断时区。

Array对象
Array是一个构造函数,故调用时要使用new来调用。
若()里面只写了一个数字,则表示该数组的长度。若里面写了多个形参,则表示该数组的各个元素。

检测对象是否为数组:
1.instanceof 运算符
语法规范: 变量名 instanceof Array;若为数组,则返回true;若不是,则返回false。

2.通过 Array.isArray(参数) IE9以上才支持!!!
若为数组,则返回true;若不是,则返回false。

js中添加和删除数组元素的方法(重要!!!)
1. push(参数) 在数组的末尾添加一个或多个数组元素。
语法规范: 数组名.push(参数)
push里面的参数可以为多个,参数直接为数组新增元素。
注意: push的返回值为新数组的长度,且原数组也发生了变化。

2. unshift() 数组的开头添加一个或多个数组元素。
和push差不多。

3. pop() 可以删除数组的最后一个元素(一次删一个),()里面无参数
语法规范: 数组名.pop()
返回值为被删除的数组元素。

4. shift() 可以删除数组的第一个元素(一次删一个),()里面无参数
和pop差不多。

数组排序
1. reverse() 颠倒数组,返回新数组。
语法规范: 数组名.reverse()

2. sort() 数组排序(但只看最前面一位)。
语法规范同上。
注意: 如果想让它实现,多位数排序,需在里面()里面写 function(a,b) { return a - b; } 即可(这样是从小到大)。
若想从大到小排序,则改为 return b - a; 即可。

返回数组索引号的方法
1. indexOf() 查找给定元素的第一个索引号,若有,则返回第一个的索引号,若没有,则返回-1。
语法规范: 数组名.indexOf(查找的元素,[])
[]表示可有可无,里面写的是查找的起始位置,若没有,则默认为0。

2. lastIndexOf() 查找给定元素的最后一个索引号
和indexOf()差不多

数组转换为字符串
1. toString()
语法规范: 数组名.toString()
这个的分隔符为 , 。

2. join() 
语法规范: 数组名.join(想要的分隔符)
若()里面不写(可为空字符串),则默认为 ,   。

数组的额外方法
1. concat() 连接两个或多个数组,返回新数组。
语法规范: 第一个数组名.concat(想要连接的数组名)
注意: 数组的连接顺序看()里面的先后顺序。

2.slice() 数组截取,返回被截取项目的新数组
语法规范: 数组名.slice(begin, end)
这个不会影响原数组。

3.splice() 数组删除 / 添加,返回 被删除 / 添加 项目的新数组
语法规范: 数组名.splice(begin, 要删除的个数) / 数组名.splice(begin, 要删除的个数(可为0), 添加的元素)
注意: 这个会影响原数组,且添加时会从begin的地方开始添加;若又要删除又添加,则先删除在添加。

字符串对象
字符串类型有length属性,是因为js将 字符串(简单数据类型) 包装为了 复杂数据类型。

这个叫 基本包装类型 ,可以方便操作基本数据类型,且js提供了三种: String, Number, Boolean。
过程为先生成 临时对象,再赋值给声明的, 再把临时对象销毁 。

根据字符返回位置
1. indexOf() 查找给定字符的第一个位置,若有,则返回第一个的位置,若没有,则返回-1。
语法规范: 数组名.indexOf(查找的字符, [])
[]表示可有可无,里面写的是查找的起始位置,若没有,则默认为0。
注意: 和数组一样,从 0 开始。

2. lastIndexOf() 查找给定元素的最后一个位置
和indexOf()差不多

根据位置返回字符
1. charAt() 返回指定位置的字符
语法规范: 对象名.charAt(索引号)
注意: 索引号和数组一样,都是从0开始。

2. charCodeAt() 返回指定位置的字符ASCII码
使用方法同上

3. str[] 返回指定位置的字符(H5新增,IE8+支持,有兼容性问题)
语法规范: str[索引号]

字符串的操作方法
1. concat() 用于连接字符串,等效于 + 
实际上 + 更常用,使用方法同数组的concat()

2. substr(start, length) 截取字符串 从start位置开始,length取的个数(重要!!!)
语法规范: 变量名.substr(start, length)

3. replace() 替换字符 返回的是替换后的新字符串,且不会影响原数组。
语法规范: 变量名.replace(被替换的字符串, 替换字符串)
注意: 它只会替换第一个字符,若想替换多个,则只需要循环并重复赋值即可。

4. split() 将字符串转换为数组
语法规范: 变量名.split(分隔符)
这里的分隔符表示字符串内是用什么把数组的元素隔开的。

5. toUpperCase 将字符串里面的字母全部转换为大写
语法规范: 变量名.toUpperCase()

6. toLowerCase 将字符串里面的字母全部转换为小写
和toUpperCase差不多。

对于内置对象的学习,可以通过查阅MDN(更为权威)和W3C来学习。
MDN中的函数形参只要带了[],则表示参数可有可无。

---------------------------------------------------------------
API(应用程序编程接口)是一些预先定义的函数,目的是提供应用程序与开发人员基于某软件或硬件得以访问一组编程的能力,且不需要看源代码,或理解内部工作机制。
简单来说: API就是一种工具,可以更轻松地完整目标。

web APIs是浏览器提供的一套操作浏览器功能和页面元素的API(DOM 和 BOM)。

MDN详细API: https://developer.mozilla.org/zh-CN/docs/Web/API


DOM
DOM是处理html元素的API,通过DOM可以改变网页的内容,结构和样式。

DOM树(元素中的包含关系画出来后像一颗树一样,故叫DOM树)
文档: 一个页面就是一个文档,DOM中用document表示。
元素: 页面中的所有标签都是元素,DOM中用element表示。
节点: 网页中所有的内容都是节点(标签,属性,文本,注释等),DOM中用node表示。
DOM把以上内容都看作是对象。

console.dir()为在控制台上打印返回元素对象的属性和方法,更方便查看,

下面()要写参数的都要加'',修改的内容也要加''。

事件: js使我们有能力创建动态页面,而事件是可以被js侦测到的行为。
简单理解就是: 触发--响应机制。
网页中的每个元素都可以添加触发js的事件。

事件由三部分组成:事件源(事件被触发的对象), 事件类型(如何触发,什么事件), 事件处理程序(通过一个函数赋值的方式完成)。

执行事件的步骤: 获取事件源, 注册事件(绑定事件), 添加事件处理程序(函数赋值)。

注意: 添加事件处理程序的过程中可以给其他元素绑定事件(重要!!!)。

获取元素通常有两种方式: 1.DOM(非常繁琐,兼容性强)。   2.节点操作(利用节点关系获取元素,逻辑性强,更为简单,但兼容性差)。

--------------------------------------------------------------------
I.DOM

DOM在实际开发中主要用来操作元素。
获取元素主要有4种方式:
1. 根据id获取
通过 getElementById()  可以获取带有id的元素对象,返回匹配id的元素对象;若没有,则返回null。
语法规范: document.getElementById(id) 
id为大小写敏感的字符串,要加引号。
注意: 由于页面是从上往下加载,得先有标签,故在相应的元素下面写<script><>/script>标签,再把js代码写在里面。


2. 根据标签名获取
(1) 通过 getElementsTagName() 可以返回带有指定标签名的对象的集合,只有一个或者无也一样(以伪数组的方式存储)。
同上,但()里面写的是标签名,一样要是字符串!!!
注意: 这里得到的内容是动态的,即上变下无需变化。

(2)还可以通过 element.getElementsByTagName() 来获取指定父元素的子元素。
使用方法同上, 但element必须为js中获取了父元素的对象。
如 var a = document.getElementByTagName('ol'); var li = a[0].getElementTagName('li');
这样就是只获取ol里面的li 。  
注意: 父元素必须为单个对象,而非一个伪数组名,且获取时不包括父元素自己。


3. 通过html5新增的方法获取(根据类名来获取,只支持IE9及以上)
(1) 通过 getElementsByClassName() 返回带有指定类名的元素对象集合。
使用方法同上。但()里面写的是类名,一样要是字符串!!!

(2) 通过 querySelector('选择器') 根据指定选择器返回第一个元素对象。
使用方法同上。
注意: 这里要表示这是什么选择器,若为类选择器,则为 .类名 ;若为id选择器,则为 #id名;若为标签选择器,则没有要加的。

(3) 通过 querySelectorAll('选择器') 根据指定选择器返回所有对象的集合。
使用方法同上,也可以通过此选择全部的元素,只需要将在''里面填入 * 即可。


4. 通过特殊元素(body, html)获取
获取这些特殊元素都有其特殊的方法

获取body标签 
语法规范: document.body 返回的是一个元素对象

获取html标签
语法规范: document.documentElement 返回的也是一个元素对象 

以上的选择方法可以叠加,即可以 document.querySelector('').querySelectorAll('')。


DOM可以改变网页的内容,结构和样式(重要!!!)。
改变元素内容(下面的都是属性)
1. 通过 对象名.innerText (非标准)
语法规范: 对象名.innerText = 修改的内容
这样就可以直接修改对应的文本,且该属性可读。
注意: innerText不识别html标签,会直接打印出来;且当输出里面的内容时,它会自动去掉里面的html标签,换行和空格。

2. 通过 对象名.innerHTML (w3c标准)
使用方法同上。但innerHTML可以识别html标签,且它会保留html标签,空格和换行。

同理,像src,id,title,href属性的修改和上述差不多,都是 对象名.修改的属性 = 修改的内容。
修改的内容尽量为字符串型。 

利用DOM可以操作type,value,checked,selected,disabled等表单属性。

js修改样式属性
1. 对象名.style 行内样式操作
语法规范: 对象名.style.需要修改的样式名 = 修改内容
注意: 需要修改的样式名采取的是驼峰命名法,且修改内容的数据类型为字符串型。
这样修改的样式为行内样式,权重为1,0,0,0。

注意: 修改背景图片这种带有url的属性时,修改的内容中必须带有url,且写法与原先一致。

2. 对象名.className 类名样式操作,可以给元素修改其类名
语法规范: 对象名.className = 相应的类名
修改内容的数据类型为字符串型。
注意: 这里的类名不加 . ,且会覆盖掉之前的类名。

若想添加新的类名或者去除其中的类名,则需要使用 对象名.classList 中的 remove() 和 add() 方法
语法规范: 对象名.classList.add(相应的类名) / 对象名.classList.remove(相应的类名)
注意: 使用循环更改类名时,尽量使用this,这样不会出现错误。

对类名修改时记得css的层叠性。

注意: getElementByTagName(),getElementsByClassName(),返回的是一个伪数组,所以要用数组里面的元素的形式触发事件。

如果有同一组元素,且只想有一个元素实现相应的样式,则需要先清除其他所有元素的样式,在实现自己的样式(排他思想)。
注意: 顺序不能颠倒,先清除其他元素的,再设置自己的。

注意: 当给一个数组循环绑定事件时,一定要用this,否则会报错(因为i的作用域不包含函数!!!)。


自定义属性(当给一个集合循环绑定事件需要每个事件显示的东西不一样时,推荐使用,因为js中的作用域问题不能使用i)
该属性可以在js中通过setAttribute来添加。
注意: 自定义属性很容易出现歧义,且难以分辨是否为自定义属性或内置属性。
故在h5中规定所有自定义属性以 data- 开头。

对象名.getAttribut('属性名') 可以获取对象对应的属性(自定义属性只能用这种方法,兼容性强)
注意: 相较于 对象名.属性 这种方法可以获取程序员自定义的新的的属性名(html中的各个标签可以添加其他的自定义属性,开发时可以方便区分)。
而自定义的属性就是程序员自己添加的属性,这样可以便于区分,使用和存储。

h5还新增了一种方法来获取自定义属性 对象名.dataset.属性名 / 对象名.dataset['属性名'] ( 属性名去掉data- )
这种方式IE11才开始支持,兼容性很差。
注意: 使用这种方法时如果自定义属性里有多个 - 连接的单词,需采用驼峰命名法,如data-list-name,必须写为listName。

js中还有另一种添加属性值(可添加自定义)的方法: 对象名.setAttribute('属性','名');
注意: 这种方法中class比较特殊,属性直接写class,而不是className。
这种方法一般用来修改自定义属性。

对象名.removeAttribute('属性') 移除属性
可以移除相应对象的属性,一般用来修改自定义属性。

-------------------------------------------------------------------------------------------------
II.节点操作

所有的节点都可以用js进行访问,且所有html都可以被修改访问和删除。

一般的,节点至少拥有nodeType(节点类型),nodeName(节点名称)和nodeValue(节点值)这三个基本属性。

nodeType
元素节点的nodeType为1
属性节点的nodeType为2
文本节点的nodeType为3(包含文字,空格,换行等,甚至还有标签之间的换行,空格也算)

实际开发中,节点操作主要操作的是元素节点。

节点层级
利用DOM树可以把节点划分为不同的层级关系,常见的是父子 兄 层级关系。

修改节点

父级节点 parentNode
语法规范: 对象名.parentNode
如<div><input/></div>,获取input后, input.parentNode 即可获取div。
注意: 这样得到的是离元素最近的父节点(亲爸爸),如果没有则返回null。

1.子节点 childNodes (标准用法)
语法规范同上。
注意: 这个获得的是所有的子节点,包含文本节点,注释和元素。返回的是一个集合(伪数组)。
如果想要里面的元素节点,则需要特殊处理,所以不提倡使用。

2.子节点 children (非标准用法,但各个浏览器都支持)
语法规范同上。这是一个只读属性,返回所有的子元素节点的集合,其余节点都不返回。
实际开发常用!!!


子节点中还有其他的相关操作
firstChild 获取第一个子节点(和childNode一样)
lastChild 获取最后一个子节点(和childNode一样)

以下两个方法有兼容性问题,IE9以上才支持。
firstElementChild 获取第一个元素节点
lastElementChild 获取最后一个元素节点

兄弟节点 nextSibling (下一个兄弟节点,包括文本节点,注释和元素)
同理,还有 previousSibling (上一个兄弟节点,包括文本节点,注释和元素)

若想获得元素节点,则有 nextElementSibling 和 previousElementSibling ,如果找不到则返回null(同样,只有IE9以上才支持)。
这个没有很好的办法解决,只能封装一个兼容性的函数解决(核心原理: 反复赋值,直到下一个兄弟节点的nodeType值为1)。
function nextElementSibling(element) {
    var a=element;
    while(a=a.nextSibling) {
        if(a.nodeType === 1)
          return a;
    }
    return null;
}


添加节点分两步: 1. 创建节点     2.添加节点。 

创建节点
document.creatElement('标签名') 返回一个对象
但只创建没用还需要把节点添加到html当中去。

添加节点
1. 对象名.appendChild(创建的新节点)
将一个节点添加到指定父节点的子节点列表末尾,类似于css里面的after伪元素,也类似于数组里面的push。
注意: 这里创建的新节点为之前创建的对象,为对象,不加引号。

2. 对象名.insertBefore(创建的新节点, 指定元素)
将一个节点添加到指定子节点的前面,类似于css中的before伪元素。
()里面的都为对象,不加引号。
注意: 指定元素为undefined时,也会自动添加到里面。

注意: input,textarea里面的值均为value属性的值,而非innerHTML !!!


删除节点
对象名.removeChild(要删除的节点) 返回删除的子节点
同理,要删除的节点为对象,不加引号。
注意: 这个只能删除子节点,不能删除父节点!!! 


复制节点(也要添加才会出现)
对象名.cloneNode() 返回调用该方法的节点的一个副本
注意: 如果()里面的参数为空或为false,则是浅拷贝,即只复制节点本身,而不复制里面的子节点。若()里面为true(数字也可以,只要为true),则为深拷贝,里面的子节点也会被复制。






