任何能执行代码的设备,都称之为计算机。

计算机语言指人与计算机通讯的语言,是人与计算机之间传递信息的媒介。
计算机语言总的来说可以分为机器语言,汇编语言和高级语言三大类。

机器语言就是计算机所执行的语言,由一堆二进制数所构成,二进制是计算机语言的基础。

编程语言就是通过类似于人的语言来让计算机为我们做事情。
通用的编程语言有两种形式: 汇编语言和高级语言。

汇编语言和机器语言的实质相同,是直接对硬件操作,但指令采用了英文缩写的标识符,容易识别和记忆。
而高级语言就是我们主要所说的编程语言,像c , c++ , javascript等。


高级语言所编写的程序不能被计算机直接识别,必须经过转换才能执行,因此,就出现了翻译器,它能够将高级语言转换为机器语言。
翻译器翻译的方式有两种: 解释和编译。两种方式的区别在于翻译的时间点不同。
编译是在代码执行前编译,生成中间代码文件(c++,java属于编译型);解释是在运行时进行及时解释,并立即执行(js就属于解释型)。


编程语言有很强的逻辑和行为能力,是主动的。
而标记语言不用向计算机发出指令,常用于格式化和链接,标记语言的存在是用来被读取的,是被动的。

计算机分为硬件和软件:
1.硬件分为5大部分
(1)输入设备: 鼠标,键盘,手写板,摄像头等
(2)输出设备: 显示器,打印机,投影仪等
(3)cpu: 负责处理数据和运算
(4)磁盘: 永久存储数据
(5)内存: 临时存储数据

2.软件分为2大部分
(1)系统软件: windows,linux,macOS
(2)应用软件: 浏览器,QQ等

所有数据都是以二进制的形式存放在硬盘中的。

程序的运行: 打开某个程序时,程序的代码会先从硬盘中被加载到内存中,cpu再执行内存中的代码,
注意:之所以需要内存,是因为cpu运行太快了,如果只从硬盘中读取数据,会浪费cpu的性能,所以,才使用存取速度更快的内存来保存运行时的数据(内存是电,硬盘是机械)。


显示器的分辨率表示显示器中的 宽由多少个小方格组成,高由多少个小方格组成,锯齿的形成就是因为电子图片本质是由小方格组成的。


计算机中,用8个二进制编码来表示一个字母,所以8bit为1B。


数据结构(重要!!!)
简单类型和复杂类型
简单类型又叫做 基本数据类型 / 值类型 , 复杂类型又叫做引用类型。

简单类型: 在存储时存储的是值本身。
复杂类型: 在存储变量时仅仅存储的时地址(引用)。

系统会把内存空间分为两个部分: 栈 和 堆。(实际上js没有堆栈的概念,只是为了易于理解)
栈: 由操作系统自动分配的存放函数的参数值,局部变量的值,复杂类型的地址(c++的数组名为地址的原因)等,操作方式和c++中的一样,简单数据类型放到栈中。
堆: 存储复杂类型(对象),一般由程序员分配释放,若程序员不释放,则由垃圾回收机制回收。

简单数据类型的传参(值传递)
由于简单数据类型和函数的参数存放在栈中,当调用函数时,函数中的参数改变了,但是实参由于和参数不在一个地方,所以实参不变。

复杂数据类型的传参(引用传递)
由于复杂数据类型的地址存放在栈中,当调用函数时,该地址指向的值变了,所以实参变了。

--------------------------------------------------------

js是一种运行在客户端的脚本语言(script就是脚本的意思)
脚本语言: 不需要编译,运行时有js解释器(js引擎)逐行来进行解释并执行。
现在也可以基于Node.js技术对服务器端进行编程。

js作用:
1.表单动态校验(密码强度检测)
2.网页特效
3.服务端开发(Node.js)
4.桌面程序(Electron)
5.App(Cordova)
6.控制硬件-物联网(Ruff)
6.游戏开发(coco2d-js)

浏览器分为两部分: 渲染引擎和js引擎。
渲染引擎: 用来解析html和css,俗称内核,如webkit,blink等。
js引擎: 也叫js解释器,用来读取web中的js代码,对其处理后运行,如chrome的V8。
注意: 浏览器本身并不会去执行js代码,而是通过内置的js引擎来执行js代码,js引擎执行代码时会逐行转化为机器语言,然后由计算机去执行。

js由三部分组成: ECMAScript(js语法), DOM(页面文档对象模型), BOM(浏览器对象模型)。
DOM是处理可扩展标记语言的标准编程接口,通过DOM提供的接口可以对页面上的各种元素进行操作(大小,位置,颜色等)
BOM提供了独立于内容的,可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口,比如弹出框,控制浏览器跳转,获取分辨率等。



js语言的一大特点是单线程语言,即同一个时间只能做一件事。
而这样就会引起一个问题,所有任务都要排队,如果js执行的时间过长,就会导致页面渲染的不连贯,导致页面渲染加载堵塞。
为了解决这个问题,利用多核cpu的能力,运行js创建多个线程,于是js中有了 同步(单线程) 和 异步(多线程) 。

js中为了防止执行时间过长,将任务分为了同步任务和异步任务
同步任务 所有的同步任务都在主线程上执行,形成一个执行栈


异步任务 js的异步都是通过回调函数执行的。
常见的异步任务 
1. 普通事件   如click, resize等
2. 资源加载   如load, error等
3. 定时器     如setInterval, setTimeout等

异步任务相关的回调函数都放到任务队列(也叫做消息队列)中。


js中的执行机制
1. 先执行栈中的同步任务
2. 将异步任务放到任务队列中,但不执行
在这个过程中有一个异步进程处理程序,如click事件,只有在点击时才会把该事件放到任务队列中。

3. 一旦执行栈中的同步任务执行完毕,系统就会依次读取队列中的异步任务,于是被读取的异步任务结束等待状态,进入执行栈,开始执行。
注意: 任务队列会不断被检查,如果有异步任务,就会执行,而这样主线程不断获得任务,执行任务,再获得,再执行,这种机制就叫做事件循环。



DOM包含在BOM里面(document属于window中的一个)。

注意: 在html中推荐使用双引号,而在js中我们推荐使用单引号。

js中的注释和css中的注释差不多,单行注释都是 ctrl + / 

-----------------------------------------------------------------------
js文件的书写方式(和之前的css差不多):
1.行内
直接写到元素的内部
如点击弹出一些东西: <button onclick="alert('md')">???</botton>
这时点击这个按钮即会弹出alert里面的内容。
注意: 外面用了双引号以后,里面就只能用单引号。同理,外面用了单引号后,里面只能用双引号。 

2.内嵌
写在<script></script>中,和之前的css差不多。

3.外部引入
将js单独写到一个文件中,再将其引入到html中。
语法规范:<script src="路径"></script> 
注意: 一旦从外部引入,则<script></script>里面就不能写代码了。

-------------------------------------------------------------------
下面为js的基本语法

js中每一句语言用 ; 隔开。

alert('')表示提醒,在web中作为显示的警示页面,点击确定后才会继续显示web的内容(引号里面为警示的内容,引号不可省),类似于printf(),但输出变量时只需要变量名即可。

console.log('') 表示浏览器控制台打印输出的信息(只有在检查里面的控制台才能看到,一般是程序员看的),类似于printf()的改版,但输出变量时只需要变量名即可。
也可以输出 12 + 12 这样的计算表达式,最终会把结果输出。
由于这样每输出一次都会换行,所以需要用字符串叠加的方式才能来输出一个字符串。
当程序错误时,其会提示出错的行数。

prompt('') 表示浏览器弹出输入框,用户可以输入,其所获取的变量的类型为string型,类似于scanf()。

在浏览器中,可以通过检查中的source来设置程序断点,进而调试(可以控制循环进行的次数)。

和c++一样,js中也有变量,本质差不多一样,为一块存放数据的内存空间。
使用变量时也和c++差不多,先声明,再赋值。

js书写规范: 操作符左右两侧需留出一个空格,for里面的小括号左右两侧要留出一个空格。

var a; 这样就声明一个叫做a的变量(定义多个变量也和c++差不多)。
赋值方式也和c++差不多。
注意: 这样声明的变量所赋的值可以为字符串,数字等(若赋值类型为字符串,需加引号,单双都可,一般为单)

var a = b = c = 9;这句话相当于var a = 9; b = 9; c = 9;(重要!!!)

变量的输入方式为 变量名 = prompt('提示信息');这样变量才能正确赋值,不能直接将变量写到prompt()中。 
但可以直接输出alert(变量名)。

若只声明,不赋值,输出时则会输出undefined;若不声明,不赋值,输出时会报错;若不声明,只赋值,则会输出相应的值(这样的话,这个会变成全局变量,不推荐使用)。
注意: 声明全局变量时不要用name作为名字!!!


变量的命名遵守驼峰命名法,即第一个单词的首字母小写,后面的单词首字母大写,其他的和c++差不多。
注意: 变量,函数的命名必须要有意义,变量的名称一般用名词,函数的名称一般用动词。

注意: js中可以阻止链接跳转,需要在a的href中将值设为 javascript:void(0); 或 javascript:; ,这样就可以阻止链接的跳转。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

warning(重要!!!): js中字符串里面的值不可变,修改时看上去是变了,实际上是变量名指向的地址变了,内存中开辟了一个新的空间。
所以,不要大量声明字符串和拼接字符串。

js中变量名不能使用 - 。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


数据类型
js是一种弱类型的语言,也可以叫动态语言,不需要声明变量的类型,在程序运行时,类型会自动确定。
在js中数据类型可以随着赋值的变化而变成不同的数据类型。

js将数据类型分为两大类: 简单数据类型(number,string,bool,undefined,null) , 复杂数据类型(object) 。

简单数据类型中的number包含了浮点数和整形。
js中数字前面加上0就表示8进制。
js中数字的前面加0x表示16进制。
js中数字的最大值是Number.MAX_VALUE(一个变量名),为17的308次方,所以无需高精度。
js中数字的最小值是Number.MIN_VALUE(同上),为50的-324次方。
在js中number还有三个特殊值 Infinity(无穷大), -Infinity(无穷小), NaN(not a number,非数值) 。

isNaN()这个用来判断是否为非数字,是,返回true ; 不是,返回false。


简单数据类型中的string,可以是引号中的任意文本,引号可以为单引号和双引号,在js中一般推荐使用单引号。
在js中的字符串中可以引号嵌套,但是外双里单,外单里双。
在js的字符串类型中也有转义字符: \n(换行) , \\(表示\) , \'(表示') , \"(表示") , \t(tab缩进) , \b(空格) 。
注意: 转义字符要写到引号里面。

通过字符串的length属性可以获取整个字符串的长度(字符串中的空格也计入长度!!!)。
若想输出字符串的长度,则只需要在相应的变量后面加上.length即可
如var str='1264'; console.log(str.length);即可输出str的长度。

字符串的拼接: 字符串 + 任意类型的变量
无论任意类型的变量是什么,最终都会变成字符串类型的变量,把变量拼接到字符串之后。
在 + 号中,数值相加,字符相连。
在输出的字符串要包含变量时,是通过字符串相连的方式实现的。


简单数据类型的bool型,只有两个值: true和false 。
和c++一样,当bool值运算时true为1,false为0。


简单数据类型中的undefined和null。
undefined是一个变量声明后没有赋值的默认值,在与字符串相连时也时undefined与字符串相连。
当undefined和一个数字相加时,结果为NaN。

null表示空对象,返回的是一个空对象!!!和字符串相连时与undefined一样。
但当它和数字相加时,由于null为空值,相当于0,所以与数字相加时结果为数字本身。
如果需要创建一个还没有想好的对象,就可以使用null。

在控制台中,不同数据类型输出时的颜色时不一样的(只有undefined和null相同)。


typeof可以用来检测变量(包括object)的具体类型。
语法规范: typeof 要检测的变量;使用console.log输出即可。console.log(typeof 要检测的变量);

数据类型转换: 将一种数据类型转换为另一种数据类型。
1.转换成字符串
(1)tostring()   方式:需要转换的变量名.tostring()
(2)String()强制转换   方式:String(需要转换的变量名)
(3)加号拼接空字符串   方式:变量 + ''   这种方式并不会直接转换,开发中常用一些。

2.转换成数字型
(1)parseInt(string) 将string转换为整数数值型 方法: parseInt(string) 
(2)parseFloat 将string转换为浮点数数值型 方法: parseFloat(string)
注意: 上面两个方法字符串的开头必须是数字,否则无效,且当它检测非数字后,会把当前非数字和后面的所有全部删掉。
还要注意其大小写。

(3)Number()强制转换 将string转换为数值型 方法: Number(string)

(4)js隐式转换(- , * , /) 利用算术运算转换 方法: '12' - 0 (字符型的数字相减也会转换为数字型)
注意: 隐式转换为数字型时,字符串后面不能有非数字。

3.转换为bool型
Boolean 将其他类型转换为bool型 方法: Boolean(要转换的值)
注意: 只有代表空,否定的值会被转换为false,如'',NaN,null,undefined,其他的都为true。


js的运算符
注意: 运算符左右都要有一个空格。
基础运算符同c++,取余都是%,还有+=,-=等,先后顺序和概念也同c++。

在js中也有和c++中一样的自增自减表达,且一定要和变量搭配一起使用(放在变量前后也和c++一样)。
注意: 当自增自减式子执行完以后就会变量就改变了。

但直接用浮点数进行运算会出现问题,所以在计算中不要直接使用浮点数进行运算(0.1 + 0.2 != 0.3)。

在js的计算中,若想保留指定位数的小数,则可以使用toFixed(保留的小数位数)
语法规范: 相应的数字.toFixed(位数)

表达式: 由数字,运算符,变量等组成的式子,称为表达式。
所有的表达式都有一个返回值,和c++一样。

比较运算符相较于c++还多了一个!==,===。
!==表示不全等,只要数据类型和值有一个不同就为真。
===表示全等,数据类型和值全部相同才为真。
注意: js中的逻辑运算符会将两边的数据类型自动转化为相同的。


逻辑运算符和c++一样。
逻辑运算中存在短路运算(也叫逻辑中断): 当有多个表达式时,左边的表达式值可以确定结果时,就不会在计算右边表达式的值!!!
注意: && 的运算优先级高于 || 。

&&中的短路运算
语法规范: 表达式1 && 表达式2;
如果第1个表达式为真,则返回表达式2;如果第1个表达式为假,则返回表达式1。

||中的短路运算
语法规范: 表达式1 || 表达式2;
如果第1个表达式为真,则返回表达式1;如果第1个表达式为假,则返回表达式2。

如果碰到连续短路运算,则需要按照计算顺序依次计算。
如123 || 456 || 789,123为真,则计算顺序为(123 || 456) || 789 。


js中的分支结构,流程控制
流程控制就是来控制代码按什么顺序来执行。

和c++一样,都依赖于if和switch。
if和switch的用法和c++一致。
js中还有c++中的三目运算符 ?:  。

if-else用于范围的判断,而switch则主要用于具体值的判断(switch的效率更高)。


js中的循环结构,用法和c++基本一致(for, while , do-while)。

for循环写法: for(var i=1;i<=100;++i)
只有定义符号变了。
注意: 当浏览器一直在加载时很有可能是写循环时进入了死循环(字符串卡死是因为数据量过大,大概率不会是字符串的情况)!!!

js中也存在continue和break,用法和c++一样。

js中的数组
js中创建数组有两种方式:
1. 利用new来创建数组
语法规范: var 数组名 = new Array();

2. 通过数组字面量来创建数组
语法规范: var 数组名 = [];
注意: 这里的数组里面可以放任意类型的元素,且元素之间的类型可以不同!!!
[]为数组中的元素,元素之间用 , 隔开。

若直接输出数组名,则会输出该数组中的所有元素和它们对应的索引号。

注意: 不要给数组名赋值,否则里面的数组元素都会消失。

js获取数组元素的方式和c++一样,且下标都是从0开始。
当js中出现数组越界或者元素不存在时,会输出undefined。

js中可以通过 数组名.length 表示数组元素的数量(数组长度),为实时监测,只要数组长度出现变化就立刻改变。
注意: 数组里面可以放对象!!!

数组新增元素:
1. 直接修改length长度
语法规范: 数组名.length = 增加后的长度;
这样数组就被修改了且原来的不动,多出来的位置的数据类型为undefined。 

2. 修改索引号(下标),
语法规范: var a=[]; a[1]=1;
这样数组a中追加了一个数组元素(非常方便!!!)。

js中还具有伪数组,伪数组具有以下特点:
1. 具有 length 属性。
2. 按照索引的方式存储数据。
3. 但没有真数组的一些方法,如pop(),push()等。


js中的函数
封装了一段可以被重复调用执行的代码块,称之为函数。

函数的使用:
1.声明函数(有两种声明方式)
(1)利用function(命名函数)
语法规范: function 函数名(形参1 , 形参2, ...){}
函数是做某件事情,所以函数名一般为动词。
这里的形参可以看作一个定义了的变量,所以不需要var,直接写形参名即可。
若实参为数组,形参也就自动变为了数组,所以无需改动。
注意: 函数不调用,自己不执行;且js中的函数不要求有返回值。

(2)变量名赋予函数表达式(匿名函数)
语法规范: var 变量名 = function(形参1 , 形参2, ...){}
这两个函数的调用方法一致。

函数中可以嵌套声明函数,但需要注意作用域的问题。

2.调用函数
和c++一样,但这里的函数可以调用另外的函数,且函数的先后顺序不会影响调用。
调用函数时()里面的值叫实参。

注意: js中的函数并不要求实参和形参必须匹配,当实参多余形参时,多余实参不参与;当实参的个数小于形参,则没有接受值的形参为undefined。

在js中,return表示将函数计算出来需要返回的值返回给调用者。
语法规范: return 需要返回的值;
同样,当函数执行到return时,后面的代码就不会执行了。
若函数没有return,则返回值undefined。
注意: return只能返回一个值(返回一个式子也可以),若有多个,则会返回最后一个,若想返回多个值,就需要以数组的形式返回(return [a,b];)。

arguments(只有函数才有)的使用
当不确定有多少个参数传递时,可以使用arguments来获取,在js中,arguments实际上是当前函数的一个内置对象(所有函数都有),arguments存储了传递的所有实参。
arguments实际上是一个伪数组。

函数中还有this这个指针,指向的是事件的调用者,若要修改对象的属性,就可以通过this.相应的属性名 = 要修改的属性 。

立即执行函数: 不需要调用,立即自己执行的函数。
语法规范: ( function() {} )() 或者 (function() {} () )
function后的第二个()可以看作是调用函数,同样,可以传参。
其最大的作用就是独立创建了一个作用域。
注意: 多个立即执行函数直之间用分号来分割,且立即执行函数可以命名。



js的作用域
一段程序所用的名字并不总是有效和可用的,该名字可用的代码范围就是这个名字的作用域。
es6之前有两种作用域:
1. 全局作用域(整个script标签或者一个外部的js文件)
2. 局部作用域(函数就是局部作用域,只在函数内部起作用)

由作用域的不同,变量可以分为两种: 全局变量和局部变量。
全局变量(注意不声明只赋值的情况)作用于全局,局部变量(形参也是局部变量)只作用于函数内部。
注意: 全局变量只有在浏览器关闭的时候才会消失,比较占内存;而局部变量在程序执行完以后就会消失。

js在es6之前没有块级作用域,es6就有了。

由内部函数可以访问外部函数变量的机制,用链式查找决定哪些数据能被内部函数访问,就称之为作用域链。
作用域链采用的原则为就近原则,哪个离函数近,就采取哪个,若上一层没有,则再往更上一层找。


js中的预解析(重要!!!)
js解析器在解析js代码时分两步: 预解析和代码执行。

预解析: js引擎会把js里面所有的var和function提升到当前作用域的最前面。
预解析分为 变量预解析(变量提升) 和 函数预解析(函数提升)。
1. 变量提升
把所有的变量声明提升到当前作用域前面。
注意: 只提升了变量声明,不提升赋值操作。

2. 函数提升
将所有的函数声明提升到当前作用域的前面。

代码执行: 按照代码书写的顺序从上往下执行。


js对象
在js中,对象是一组无序的相关属性和方法的集合,所有的具体事物都是对象,可以使表达的结构更为清晰。
所以对象是由属性和方法组成的。
属性: 事物的特征。      方法: 事物的行为。

创建对象共有三种方式:
1.利用字面量来创建对象
语法规范: var 变量名 = {对象的信息(包含属性和方法)}
属性的写法: 属性名: 值,
方法的写法: 方法名: function(){}
注意: 每个信息之间用 , 隔开,最后一个信息可以不跟 , 。
这个也可以追加信息,方式同下。

2.利用new Object创建对象
语法规范: var 变量名 = new Object();
若想追加信息,则在下面单独书写。
变量名.信息 = 代码;
注意: 这时每个信息之间用 ; 隔开。

3.利用构造函数创建对象(构造函数首字母要大写,这是规范)
这种方法一次可以创建多个对象,前面的一次只能创建一个,构造函数实际上就是一大类(同c++的class)。
语法规范: function 构造函数名(形参1 , 形参2, ...) {
    this.属性 = 值;
    this.方法 = function (形参) {}
}
调用该函数的方法也不同: var 变量名 = new 构造函数名(实参1, 实参2, ...);
这里的this指向的是相应的对象。
注意: 使用这种方法时,构造函数返回的对象要赋予一个变量(构造函数不需要return)。

对象的实例化就是利用构造函数创建对象。

new在调用构造函数是的作用
new 构造函数(实参) 就是在内存中创建了一个空对象,而构造函数中的this就会指向这个对象(同指针),然后就会执行构造函数里面得的代码,最后返回。


对象的使用
调用对象的属性有两种方法
(1) 对象名.属性名           (2)对象名['属性名'](引号不能省)

调用对象的方法: 对象名.方法名()   。 

对象的遍历
for...in 语句可以用于对数组或对象的属性进行循环操作!!!
语法规范: for(变量 in 对象)
for(var k in 对象名) console.log(k);这样即可输出对象的所有信息名。
for(var k in 对象名) console.log(对象名[k]);这样即可输出对象的所有信息值。
这里的k不加引号!!!


js的内置对象
js中对象分三种: 自定义对象, 内置对象, 浏览器对象。
前两种对象是js的基础内容,属于es;浏览器对象为js特有的。

内置对象就是js语言自带的一些对象,这些对象供开发者使用,并提供了常用的或是最基本而必要的一些功能。
js中的内置对象: Math,Date,Array,String等。

Math对象(非构造函数,不需要new)
Math.PI表示圆周率,Math.max()表示求最大值(若给的数值中有至少一个为非数字类型的,则返回NaN;若小括号为空,则返回-Infinity)。
Math.abs()表示求绝对值(这里存在隐式转换,会把字符型的数字转换为数字型)。
Math.floor()表示向下取整,Math.ceil()表示向上取整,Math.round()则表示四舍五入就近取整,但如果小数部分为 .5 的话往大了取(-3.5 的结果为 -3)。

Math.random()表示返回一个随机浮点数,范围为[0,1),()里面不跟参数。
若想使它取整数且在一个范围之内,需要用到上面的取整,通过数学方式来实现。
Math.floor(Math.random() * (max - min + 1)) + min 取值范围即为[min,max]。
注意: 若使用ceil,则min的概率很小很小,所以不使用ceil。

Date对象
Date是一个构造函数,故调用时要使用new来调用。
如果Date()中的()没有输入任何的参数,则Date的构造器会依据系统设置的时间来创建一个Date对象。
()内参数常用的写法: 数字型 2010, 10, 1 或者是 字符串型 '2010-10-1 8:8:8'
注意: 使用数字型时,输出的月份会比输入的月份大一个月,字符串型则没有这种问题。

getFullYear()表示返回对象的年份;getMonth()表示当前的月份,但由于是从0开始,所以返回的月份会比当前的月份小一个月。
getDate()表示返回对象的日期;getDay()表示当前是星期几(周日返回的是0,若想中文化,可以使用数组来显示)
同理getHours(),getMinutes(),getSeconds()分别返回小时,分钟,秒。

Date对象是基于1970.1.1起的毫秒数。
若想获得当前距离1970.1.1过了多少毫秒数(也叫时间戳,可以用于加密),有两种方法:
1. 通过 valueOf()
语法规范: Date对象名.valueOf()

2.通过 getTime()
语法规范: 同上

3.通过 +new Date() (常用!!!)
语法规范: var 变量名 = +new Date();
若括号为空,则返回当前时间距离1970.1.1的毫秒数;若不为空,则返回括号中时间距离1970.1.1的毫秒数。
这样变量即为上述的毫秒数,里面为字符串。

4.通过 Date.now() (H5新增的)
语法规范: console.log(Date.now());
直接输出即可。

倒计时核心: 输入的时间减去当前的时间,但不能直接减,故采用时间戳来做,减去以后再转换为年月日时分秒。

时间戳计算的小时数和正常时间差8小时是因为时区的问题,所以尽量使用getHours(),这个会自动判断时区。

Array对象
Array是一个构造函数,故调用时要使用new来调用。
若()里面只写了一个数字,则表示该数组的长度。若里面写了多个形参,则表示该数组的各个元素。

检测对象是否为数组:
1.instanceof 运算符
语法规范: 变量名 instanceof Array;若为数组,则返回true;若不是,则返回false。

2.通过 Array.isArray(参数) IE9以上才支持!!!
若为数组,则返回true;若不是,则返回false。

js中添加和删除数组元素的方法(重要!!!)
1. push(参数) 在数组的末尾添加一个或多个数组元素。
语法规范: 数组名.push(参数)
push里面的参数可以为多个,参数直接为数组新增元素。
注意: push的返回值为新数组的长度,且原数组也发生了变化。

2. unshift() 数组的开头添加一个或多个数组元素。
和push差不多。

3. pop() 可以删除数组的最后一个元素(一次删一个),()里面无参数
语法规范: 数组名.pop()
返回值为被删除的数组元素。

4. shift() 可以删除数组的第一个元素(一次删一个),()里面无参数
和pop差不多。

数组排序
1. reverse() 颠倒数组,返回新数组。
语法规范: 数组名.reverse()

2. sort() 数组排序(但只看最前面一位)。
语法规范同上。
注意: 如果想让它实现,多位数排序,需在里面()里面写 function(a,b) { return a - b; } 即可(这样是从小到大)。
若想从大到小排序,则改为 return b - a; 即可。

返回数组索引号的方法
1. indexOf() 查找给定元素的第一个索引号,若有,则返回第一个的索引号,若没有,则返回-1。
语法规范: 数组名.indexOf(查找的元素,[])
[]表示可有可无,里面写的是查找的起始位置,若没有,则默认为0。

2. lastIndexOf() 查找给定元素的最后一个索引号
和indexOf()差不多

数组转换为字符串
1. toString()
语法规范: 数组名.toString()
这个的分隔符为 , 。

2. join() 
语法规范: 数组名.join(想要的分隔符)
若()里面不写(可为空字符串),则默认为 ,    。

数组的额外方法
1. concat() 连接两个或多个数组,返回新数组。
语法规范: 第一个数组名.concat(想要连接的数组名)
注意: 数组的连接顺序看()里面的先后顺序。

2.slice() 数组截取,返回被截取项目的新数组
语法规范: 数组名.slice(begin, end)
这个不会影响原数组。

3.splice() 数组删除 / 添加 , 返回 被删除 / 添加 项目的新数组
语法规范: 数组名.splice(开始的位置, 要删除的个数) / 数组名.splice(开始的位置, 要删除的个数(可为0), 添加的元素)
注意: 这个会影响原数组,且添加时会从begin的地方开始添加;若又要删除又添加,则先删除在添加。

字符串对象
字符串类型有length属性,是因为js将 字符串(简单数据类型) 包装为了 复杂数据类型。

这个叫 基本包装类型 ,可以方便操作基本数据类型,且js提供了三种: String, Number, Boolean。
过程为先生成 临时对象,再赋值给声明的, 再把临时对象销毁 。

根据字符返回位置
1. indexOf() 查找给定字符的第一个位置,若有,则返回第一个的位置,若没有,则返回-1。
语法规范: 数组名.indexOf(查找的字符, [])
[]表示可有可无,里面写的是查找的起始位置,若没有,则默认为0。
注意: 和数组一样,从 0 开始。

2. lastIndexOf() 查找给定元素的最后一个位置
和indexOf()差不多

根据位置返回字符
1. charAt() 返回指定位置的字符
语法规范: 对象名.charAt(索引号)
注意: 索引号和数组一样,都是从0开始。

2. charCodeAt() 返回指定位置的字符ASCII码
使用方法同上

3. str[] 返回指定位置的字符(H5新增,IE8+支持,有兼容性问题)
语法规范: str[索引号]

字符串的操作方法
1. concat() 用于连接字符串,等效于 + 
实际上 + 更常用,使用方法同数组的concat()

2. substr(start, length) 截取字符串 从start位置开始,length取的个数(重要!!!),返回被截取的字符串
语法规范: 变量名.substr(start, length)
如果第二个参数省略则默认截取到最后一个。

3. replace() 替换字符 返回的是替换后的新字符串,且不会影响原数组。
语法规范: 变量名.replace(被替换的字符串, 替换字符串)
注意: 它只会替换第一个字符,若想替换多个,则只需要循环并重复赋值即可。

4. split() 将字符串转换为数组
语法规范: 变量名.split(分隔符)
这里的分隔符表示字符串内是用什么把数组的元素隔开的。

5. toUpperCase 将字符串里面的字母全部转换为大写
语法规范: 变量名.toUpperCase()

6. toLowerCase 将字符串里面的字母全部转换为小写
和toUpperCase差不多。

对于内置对象的学习,可以通过查阅MDN(更为权威)和W3C来学习。
MDN中的函数形参只要带了[],则表示参数可有可无。

---------------------------------------------------------------
API(应用程序编程接口)是一些预先定义的函数,目的是提供应用程序与开发人员基于某软件或硬件得以访问一组编程的能力,且不需要看源代码,或理解内部工作机制。
简单来说: API就是一种工具,可以更轻松地完整目标。

web APIs是浏览器提供的一套操作浏览器功能和页面元素的API(DOM 和 BOM)。

MDN详细API: https://developer.mozilla.org/zh-CN/docs/Web/API


DOM
DOM是处理html元素的API,通过DOM可以改变网页的内容,结构和样式。

DOM树(元素中的包含关系画出来后像一颗树一样,故叫DOM树)
文档: 一个页面就是一个文档,DOM中用document表示。
元素: 页面中的所有标签都是元素,DOM中用element表示。
节点: 网页中所有的内容都是节点(标签,属性,文本,注释等),DOM中用node表示。
DOM把以上内容都看作是对象。

console.dir()为在控制台上打印返回元素对象的属性和方法,更方便查看,


事件: js使我们有能力创建动态页面,而事件是可以被js侦测到的行为。
简单理解就是: 触发--响应机制。
网页中的每个元素都可以添加触发js的事件。

而添加事件,首先就要获取元素。
获取元素通常有两种方式: 1.DOM(非常繁琐,兼容性强)。   2.节点操作(利用节点关系获取元素,逻辑性强,更为简单,但兼容性差)。

--------------------------------------------------------------------
I.DOM

DOM在实际开发中主要用来操作元素,且获取的DOM元素都是一个对象,所以叫 文档对象模型 。
获取元素主要有4种方式:
1. 根据id获取
通过 getElementById()  可以获取带有id的元素对象,返回匹配id的元素对象;若没有,则返回null。
语法规范: document.getElementById(id) 
id为大小写敏感的字符串,要加引号。
注意: 由于页面是从上往下加载,得先有标签,故在相应的元素下面写<script><>/script>标签,再把js代码写在里面。


2. 根据标签名获取
(1) 通过 getElementsTagName() 可以返回带有指定标签名的对象的集合,只有一个或者无也一样(以伪数组的方式存储)。
同上,但()里面写的是标签名,一样要是字符串!!!
注意: 这里得到的内容是动态的,即上变下无需变化。

(2)还可以通过 element.getElementsByTagName() 来获取指定父元素的子元素。
使用方法同上, 但element必须为js中获取了父元素的对象。
如 var a = document.getElementByTagName('ol'); var li = a[0].getElementTagName('li');
这样就是只获取ol里面的li 。  
注意: 父元素必须为单个对象,而非一个伪数组名,且获取时不包括父元素自己。


3. 通过html5新增的方法获取(根据类名来获取,只支持IE9及以上)
(1) 通过 getElementsByClassName() 返回带有指定类名的元素对象集合。
使用方法同上。但()里面写的是类名,一样要是字符串!!!

(2) 通过 querySelector('选择器') 根据指定选择器返回第一个元素对象。
使用方法同上。
注意: 这里要表示这是什么选择器,若为类选择器,则为 .类名 ;若为id选择器,则为 #id名;若为标签选择器,则没有要加的。

(3) 通过 querySelectorAll('选择器') 根据指定选择器返回所有对象的集合。
使用方法同上,也可以通过此选择全部的元素,只需要将在''里面填入 * 即可。


4. 通过特殊元素(body, html)获取
获取这些特殊元素都有其特殊的方法

获取body标签 
语法规范: document.body 返回的是一个元素对象

获取html标签
语法规范: document.documentElement 返回的也是一个元素对象 

以上的选择方法可以叠加,即可以 document.querySelector('').querySelectorAll('')。


DOM可以改变网页的内容,结构和样式(重要!!!)。
改变元素内容(下面的都是属性)
1. 通过 对象名.innerText (非标准)
语法规范: 对象名.innerText = 修改的内容
这样就可以直接修改对应的文本,且该属性可读。
注意: innerText不识别html标签,会直接打印出来;且当输出里面的内容时,它会自动去掉里面的html标签,换行和空格。

2. 通过 对象名.innerHTML (w3c标准)
使用方法同上。但innerHTML可以识别html标签,且它会保留html标签,空格和换行。
且可以创建新的标签,创建多个元素时效率相较更高(结构更为复杂,需采用数组的形式来拼接,而非字符串拼接!!!)。

同理,像src,id,title,href属性的修改和上述差不多,都是 对象名.修改的属性 = 修改的内容。
修改的内容尽量为字符串型。 

利用DOM可以操作type,value,checked,selected,disabled等表单属性。

js修改样式属性
1. 对象名.style 行内样式操作
语法规范: 对象名.style.需要修改的样式名 = 修改内容
注意: 需要修改的样式名采取的是驼峰命名法,且修改内容的数据类型为字符串型。
这样修改的样式为行内样式,权重为1,0,0,0。

注意: 修改背景图片这种带有url的属性时,修改的内容中必须带有url,且写法与原先一致。

修改transform属性的格式为 对象名.style.transform = 'translateX(1px)';


2. 对象名.className 类名样式操作,可以给元素修改其类名
语法规范: 对象名.className = 相应的类名
修改内容的数据类型为字符串型。
注意: 这里的类名不加 . ,且会覆盖掉之前的类名。


对象名.classList 可以返回元素类名的集合

若想添加新的类名或者去除其中的类名,则需要使用 对象名.classList 中的 remove() 和 add() 方法
语法规范: 对象名.classList.add(相应的类名) / 对象名.classList.remove(相应的类名)

还可以切换类名(没有就加上,有就删掉)
语法规范: 对象名.classList.toggle(相应的类名)

注意: 使用循环更改类名时,尽量使用this,这样不会出现错误。

对类名修改时记得css的层叠性。


注意: getElementByTagName(),getElementsByClassName(),返回的是一个伪数组,所以要用数组里面的元素的形式触发事件。

如果有同一组元素,且只想有一个元素实现相应的样式,则需要先清除其他所有元素的样式,在实现自己的样式(排他思想)。
注意: 顺序不能颠倒,先清除其他元素的,再设置自己的。

注意: 当给一个数组循环绑定事件时,一定要用this,否则会报错(因为i的作用域不包含函数!!!)。

js中还有一种添加属性值(可添加自定义)的方法: 对象名.setAttribute('属性', 值);
注意: 这种方法中class比较特殊,属性直接写class,而不是className。
这种方法一般用来修改自定义属性。

自定义属性(当给一个集合循环绑定事件需要每个事件显示的东西不一样时,推荐使用,因为js中的作用域问题不能使用i)

该属性可以在js中通过 对象名.setAttribute() 来添加。
注意: 自定义属性很容易出现歧义,且难以分辨是否为自定义属性或内置属性。
故在h5中规定所有自定义属性以 data- 开头。

对象名.getAttribut('属性名') 可以获取对象对应的属性值!!!(自定义属性只能用这种方法,兼容性强)
注意: 相较于 对象名.属性 这种方法可以获取程序员自定义的新的的属性名(html中的各个标签可以添加其他的自定义属性,开发时可以方便区分)。
而自定义的属性就是程序员自己添加的属性,这样可以便于区分,使用和存储。

h5还新增了一种方法来获取自定义属性 对象名.dataset.属性名 / 对象名.dataset['属性名'] ( 属性名去掉data- )
这种方式IE11才开始支持,兼容性很差。
注意: 使用这种方法时如果自定义属性里有多个 - 连接的单词,需采用驼峰命名法,如data-list-name,必须写为listName。


对象名.removeAttribute('属性') 移除属性
可以移除相应对象的属性,一般用来修改自定义属性。

-------------------------------------------------------------------------------------------------
II.节点操作

所有的节点都可以用js进行访问,且所有html都可以被修改访问和删除。

一般的,节点至少拥有nodeType(节点类型),nodeName(节点名称)和nodeValue(节点值)这三个基本属性。

nodeType
元素节点的nodeType为1
属性节点的nodeType为2
文本节点的nodeType为3(包含文字,空格,换行等,甚至还有标签之间的换行,空格也算)

实际开发中,节点操作主要操作的是元素节点。

节点层级
利用DOM树可以把节点划分为不同的层级关系,常见的是父子 兄 层级关系。


修改节点

父级节点 parentNode
语法规范: 对象名.parentNode
如<div><input/></div>,获取input后, input.parentNode 即可获取div。
注意: 这样得到的是离元素最近的父节点(亲爸爸),如果没有则返回null。

1.子节点 childNodes (标准用法)
语法规范同上。
注意: 这个获得的是所有的子节点,包含文本节点,注释和元素。返回的是一个集合(伪数组)。
如果想要里面的元素节点,则需要特殊处理,所以不提倡使用。

2.子节点 children (非标准用法,但各个浏览器都支持)
语法规范同上。这是一个只读属性,返回所有的子元素节点的集合,其余节点都不返回。
实际开发常用!!!


子节点中还有其他的相关操作
firstChild 获取第一个子节点(和childNode一样)
lastChild 获取最后一个子节点(和childNode一样)

以下两个方法有兼容性问题,IE9以上才支持。
firstElementChild 获取第一个元素节点
lastElementChild 获取最后一个元素节点

兄弟节点 nextSibling (下一个兄弟节点,包括文本节点,注释和元素)
同理,还有 previousSibling (上一个兄弟节点,包括文本节点,注释和元素)

若想获得元素节点,则有 nextElementSibling 和 previousElementSibling ,如果找不到则返回null(同样,只有IE9以上才支持)。
这个没有很好的办法解决,只能封装一个兼容性的函数解决(核心原理: 反复赋值,直到下一个兄弟节点的nodeType值为1)。
function nextElementSibling(element) {
    var a=element;
    while(a=a.nextSibling) {
        if(a.nodeType === 1)
          return a;
    }
    return null;
}


添加节点分两步: 1. 创建节点     2.添加节点。 

创建节点
(1) document.creatElement('标签名') 返回一个对象
但只创建没用还需要把节点添加到html当中去。

(2) document.write('标签名')
注意: 该方法是直接将内容写到页面的内容流里面,但是当文档流执行完毕后,会导致页面的全部重绘(重新创建一个新的html页面,不推荐使用)。

(3)

添加节点
1. 对象名.appendChild(创建的新节点)
将一个节点添加到指定对象的子节点列表末尾,类似于css里面的after伪元素,也类似于数组里面的push。
注意: 这里创建的新节点为之前创建的对象,为对象,不加引号。

2. 对象名.insertBefore(创建的新节点, 指定元素)
将一个节点添加到指定子节点的前面,类似于css中的before伪元素。
()里面的都为对象,不加引号。
注意: 指定元素为undefined时,也会自动添加到里面。

注意: input,textarea里面的值均为value属性的值,而非innerHTML !!!


删除节点
对象名.removeChild(要删除的节点) 返回删除的子节点
同理,要删除的节点为对象,不加引号。
注意: 这个只能删除子节点,不能删除父节点!!! 


复制节点(也要添加才会出现)
对象名.cloneNode() 返回调用该方法的节点的一个副本
注意: 如果()里面的参数为空或为false,则是浅拷贝,即只复制节点本身,而不复制里面的子节点。若()里面为true(数字也可以,只要为true),则为深拷贝,里面的子节点也会被复制。

---------------------------------------------------------------------------------------------------------------------------------------------------------

事件由三部分组成:事件源(事件被触发的对象), 事件类型(如何触发,什么事件), 事件处理程序(通过一个函数赋值的方式完成)。

DOM事件流
事件流描述的是页面接受事件的顺序。
事件发生时会在元素节点之间按照特定的顺序传播,这个传播的过程就是DOM事件流。
就是针对于孩子和父亲都绑定了相同的事件后触发事件时先执行谁的问题。


DOM事件流分为三个阶段: 
1. 捕获阶段
从document开始,再到html,再到body,最终找到特定的元素。

2. 当前目标阶段
特定元素绑定事件。

3. 冒泡阶段
从该元素开始,到父元素,到父亲的父元素,...,到body,到html,到document。

注意: js代码只能执行捕获或者冒泡其中的一个阶段,且传统事件和attachEvent只能得到冒泡阶段。
若为捕获,则从document开始,依次向下执行相同的事件,最后再执行该元素的;若为冒泡,则优先执行该元素的,再依次向上执行相同的事件。

实际开发中更为关注事件冒泡,而非事件捕获。
事件冒泡有利有弊,看情况使用。
注意: 有些事件是没有冒泡的,如onblur, onfocus, onmouseenter, onmouseleave。


事件对象(IE9以下只支持 window.event ,不能少一个字母)
添加事件处理程序时,function() {} 中的()中可以写东西,这个就叫事件对象(可当形参来看)。
注意: 事件对象只有事件存在时才会存在,为系统自动创建的,不需要传递参数。

事件对象是事件一系列相关数据的集合,这些数据和事件相关,如onclick事件就包含了鼠标的相关信息(鼠标坐标等);如果是键盘事件,就包含了和键盘有关的信息,如按下了哪个键。
一般在()写作e(可自己命名)。

兼容性写法: e = e || window.event;(不太考虑)

事件对象的常见属性和方法:
e.target 返回触发事件的对象(ie678为e.srcElement)
注意: e.target返回的是触发事件的对象(父元素绑定点击事件时点击其子元素,则返回子元素,点谁反谁),而this返回的是绑定事件的对象。

e.type 返回事件的类型(不带on)
e.preventDefault() 方法,阻止默认事件(默认行为),比如链接的跳转,表单的提交(ie678为e.returnValue ,为属性)
直接写在事件中即可,且不需要传参。
传统方式中可以在最后一句中加上return false来阻止默认事件(无兼容性问题,但其后面的代码就不会执行了)。

e.stopPropagation() 方法,阻止冒泡(ie678为e.canceBubble ,为属性)
直接写在事件中即可,且不需要传参。


鼠标事件对象 MouseEvent
e.clientX 返回鼠标相对于浏览器窗口的可视区(body)的X坐标(不管是否有滚动条)
e.clientY ~Y坐标
e.pageX 返回鼠标相对于文档页面(html)的X坐标,IE9以上才支持(重点使用!!!)
e.pageY ~Y坐标
e.screenX 返回鼠标相对于电脑屏幕的X坐标
e.screenY ~Y坐标

注意: 以上均为单纯的数值,若要添加到css里面,需要添加px字符串。

键盘事件对象 KeyboardEvent
e.keyCode 返回按下键的ASCII值



事件委托
事件委托也称之为事件代理,在jQuery里面称之为事件委派。
原理: 不是给每个子节点设置事件监听器,将事件监听器设置在父节点上,让后利用冒泡原理设置每一个子节点,通过事件对象的target来找到点击的子节点(重要)。

这样只操作了一次DOM,提高了程序的性能。

但这个方法对于子元素里面还套有子元素的情况来说,效果不佳。

------------------------------------------------------------------------------
常用的鼠标事件(传统事件需要在前面加 on ): 
contextmenu 控制应该何时显示鼠标右键单击出现的菜单,主要用于取消默认的菜单。
可用return false(事件监听不可用) , e.preventDefault() 来阻止,但防不了插件。

selectstart 开始选中
可用return false(事件监听不可用) , e.preventDefault() 就可以阻止选中。
只能限制小白。

mousemove 只要鼠标移动1px就会触发事件。
若要给在整个页面给鼠标换样式(cursor灵敏度不好),需给整个document添加该事件!!!

mouseenter 鼠标移动到元素上时就会触发
其和mouseover的区别是mouseenter不会触发DOM事件流中的冒泡。
同理mouseleave也不会触发冒泡。


常用的键盘事件(传统事件需要在前面加 on )
keyup 某个键盘按键被松开时触发(不区分字母大小写)

keydown 某个按键被按下时触发(持续按下不动时有效,不区分字母大小写,适合不需要输入文字的)

keypress 某个按键被按下时触发,但无法识别功能键,如ctrl,shift等(持续按下不动时有效,区分字母大小写)

注意: 如果以上两个事件都被触发,则优先执行keydown;且它们的事件触发的时候,为先触发事件,文字不会没有落入文本框中,事件处理程序执行完后文字才会落入文本框。
而keyup则是先将文字落入文本框,再触发事件。
-------------------------------------------------------------------------------------------------------

常用的方法
对象名.focus()
使当前的对象获得鼠标光标
注意: 在按下某个键使得一个input或文本域获得光标时,若使用keydown / keypress,会把你按的那个字符也输进去,所以要使用keyup。



-----------------------------------------------------------------------

执行事件的步骤: 获取事件源, 注册事件(绑定事件), 添加事件处理程序(函数赋值)。

1.注册事件
注册事件有两种方式: 传统方式和方法监听注册方式。

传统方式的事件都是以 on 开头的,如onclick。
特点: 注册事件的唯一性(同一个元素同一个事件只能设置一个处理函数,最后注册的处理函数会覆盖掉前面的)。
若后面跟函数,则函数不加()。

方法监听注册方式(w3c推荐做法,推荐)
addEventListener()便是一个方法,但只有IE9以上的浏览器支持,IE9以下需使用attachEvent()代替。
特点: 同一个元素同一个事件可以注册多个监听器。

addEventListener()
语法规范: 对象名.addEventListener(type, listener[, useCapture])
type表示监听的事件类型(click,mouseover等,不能加on ,要加引号!!! )。
listener表示事件处理函数,事件发生时,会调用该函数,就是function,写法也一样,只是写在()里面。
注意: 若要考虑到删除事件,则事件处理函数要在外面写,在将函数名写在该位置,这里调用函数时不要()。
useCapture为可选参数,是bool类型,默认为false,表示在事件冒泡阶段调用事件处理程序;若为true,则表示在事件捕获阶段调用事件处理程序。

attachEvent()   最不推荐使用,且只有IE9以前才起效果!!!(可不看)
语法规范: 对象名.attachEvent(事件, callback)
事件为字符串类型,且必须要带有on,要加引号!!!
callback为事件处理函数,当触发事件时回调函数被调用,也就是function。

注意: 添加事件处理程序的过程中可以给其他元素绑定事件(重要!!!)。

2.删除事件(解绑事件)
传统方式
在事件处理函数的最后一句中添加 相应的对象名.onclick = null; 即可

方法监听注册方式 removeEventlistner()
语法规范: 对象名.removeEventlistner(type, 对应的函数名)
这句代码在对应的事件处理函数的最后一句中写,且若要实现,则监听注册的事件处理函数需写在 addEventListener 外面。


事件的手动触发
如click事件,手动调用的方法为 对象名.click();
这样即可手动调用click事件。


还可以用if检测对象是否设置了事件
语法规范: if("addEventListener" in 对象名) 事件监听方式
若设置了事件,则为真,执行后面的语句。

--------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

BOM 浏览器对象模型

BOM是浏览器对象模型,提供了独立于内容而与浏览器窗口进行交互的对象,核心(顶级)对象为windows。
注意: BOM缺乏标准,各个浏览器自己规定,兼容性比较差。

DOMContentLoaded事件是专属于document的事件,DOM加载完成时就触发,且不包含样式表,flash,图片等,IE9以上才支持。
因为当图片较多时,onload触发需要的时间长,需要的交互效果不能及时出现,使用这个更为合适。

在全局对象和普通函数下,this都指向的是window。
一般情况下this都指向的是调用者。

window对象 浏览器顶级对象
1. 为js访问浏览器窗口的一个接口。
2. 为一个全局对象。定义在全局作用域中的变量,函数都会变成window对象的属性和方法。
调用时可以省略window。

注意: window下有一个特殊的属性window.name,故声明全局变量时不要命名为name。


window对象常见事件
1. 窗口加载事件 window.onload = function() {}         传统方式
当文档内容完全加载完成后才会触发该事件,才会调用处理函数(可以把js放到任何一个地方,而非文档的最后)。
也可以使用事件监听的方法来写(注意去掉on)。

当a的超链接,强制刷新,前进或后退按钮刷新页面时就会触发事件。
但在firefox中,它会将DOM和js状态保存到内存中,所以无法触发load事件。

2. 调整窗口大小事件 window.onresize = function() {}
当窗口大小变化时就会触发的事件。
可以用这个来制作响应式布局。

3. 重新加载页面时触发的事件 window.ompageshow = function() {}
当页面显示时触发的事件。

firefox的机制也可以触发该事件,但需通过事件对象中的persisted来判断是否为缓存中的页面触发该事件,且触发顺序后于load。


window对象常见属性
1. 当前屏幕的宽度 innerWidth
2. 当前屏幕的物理像素比 devicePixelRatio ( 本人笔记本电脑的物理像素比为1.5 )


window对象的定时器方法
1. setTimeout()
语法规范: window.setTimeout(调用函数, [延迟的毫秒数])
这个调用函数可以像事件一样现写,也可以写函数名( 不加() );且这个延迟的毫秒数单位必须为毫秒,如果该形参省略,则默认为0。
在调用时window可以省略,且这个方法只调用一次,而且是先经过相应的毫秒数后再执行。
注意: 页面中可能会有多个定时器,我们需要将他们赋予一个变量来方便区分。

停止 setTimeout()定时器
clearTimeout()
语法规范: window.clearTimeout(定时器赋予的变量)
同理,window可省略。

2. setInterval()
语法规范: window.setInterval(调用函数, [间隔的毫秒数])
这个基本同上,但每经过间隔的毫秒数后就会去调用回调函数。
注意: 这个函数第一次执行时也有间隔,所以要先执行一次调用函数,就可以解决刚刷新时的页面空白问题。

停止 setInterval()定时器
clearInterval()
语法规范: window.clearInterval(定时器赋予的变量)
同理,window可省略。

注意: 重新开启定时器之前要先清除定时器!!!
定时器的调用函数也叫做回调函数callback。


window对象下的location属性
这个属性可以获取并设置窗体的URL,并且可以用于解析URL,因为这个属性返回的是一个对象,所以也称之为location对象。

URL是互联网上标准资源的地址,互联网上的每个文件都有一个唯一的URL,它包含的信息会指出文件的位置以及浏览器应该怎么处理它。

location对象的常见属性
href 获取或设置整个URL
host 返回主机(域名)
port 返回端口号,若没有,则返回 空字符串
pathname 返回路径
search 返回参数(这个是带 ? 的),以键值对的方式,用 & 分割
hash 返回片段,即 # 后面的内容,常见于链接,锚点

如果在js中修改 location.href ,就会直接跳转到新的页面去。
注意: 使用这个跳转时,一定要输入完整的网址(包括前面的协议)!!!否则会在当前目录下查找。

location对象的常见方法
location.assign() 跳转到其他页面
直接写,()里面为跳转的网址,要加引号!!!
注意: 这个是记录浏览历史的,所以可以实现后退功能。

location.replace() 替换当前页面
同上,()里面为替换的网址。但没有后退效果。 

location.reload() 重新加载页面
直接写,()里面为bool值,默认为false;若为true,则为 ctrl + F5 强制刷新。


navigator对象
这个对象包含了有关浏览器的信息,具有很多属性,最常用的为userAgent,该属性可以返回有客户机发送服务器的user-agent头部的值。


history对象
这个对象用于与浏览器历史记录进行交互,包含了用户之前访问的URL。

history对象的常用方法
back() 实现后退功能
直接写,前面要加history。

forward() 前进功能
直接写,前面要加history。

go() 前进后退功能
直接写,前面要加history。()里面要写参数;参数如果是1,则为前进1个页面;若为-1,则为后退一个页面。

----------------------------------------------------------------------------------------------

网页特效


offset 元素偏移量
利用offset系列相关属性可以动态的得到该元素的位置,大小等。
1. 可以获取元素距离带有定位父元素的位置。
2. 可以获取元素自身的大小( width 和 height )。
注意: 返回的数值不带单位。

offset常用属性
对象名.offsetParent 返回作为该元素且带有定位的父元素,若父级都没有定位则返回body。
对象名.offsetTop 返回元素相对带有定位父元素(没有则为body)上方的偏移
对象名.offsetLeft 返回元素相对带有定位父元素(没有则为body)左边框的偏移
注意: 无 right 和 bottom 。

对象名.offsetWidth 返回自身包括padding,边框,内容区的宽度,返回值无单位
对象名.offsetHeight 返回自身包括padding,边框,内容区的高度,返回值无单位


offset与style的区别
1. style只能获得行内样式表的样式,而offset可以获得任意样式表中的样式。
2. style获得的是字符串型且有单位,而offset获得的是数字型且无单位。
3. style只能获取width。
4. offset只能获取,不能赋值,而style可以赋值。
所以,获取更合适用offset,修改用style。


拖动移动框需要三个事件: mousedown(鼠标按下) ,mousemove(鼠标移动) ,mouseup(鼠标弹起)。
注意触发事件的位置要确定好。
原理为 鼠标坐标 - 鼠标在盒子内的坐标 。
注意: 计算完之后的结果记得 + 'px';且该 mousemove 的事件要添加到document!!!

京东伪放大镜的效果 
盒子随鼠标移动的原理是 鼠标在盒子内的坐标赋予给放大镜盒子的坐标,盒子的坐标还要减去自身的一半,还要加if来限制放大镜盒子的伪装。
大图的原理是 鼠标在盒子中的坐标等比放大并赋值到相应盒子中图片的坐标,同时限制范围。
注意: 计算完后记得 + 'px'。



client 元素可视区
利用client系列相关属性可以获取元素可视区的相关信息,动态地获取如元素的边框大小,元素大小等信息。

client常见属性
对象名.clientTop 返回元素上边框的大小
对象名.clientLeft 返回元素下边框的大小
对象名.clientWidth 返回自身包括padding,内容区的宽度,不含边框,返回数值不带单位
对象名.clientHeight 返回自身包括padding,内容区的高度,不含边框,返回数值不带单位



scroll 元素滚动
利用scroll系列相关属性可以动态的得到该元素的大小,滚动距离等,主要和滚动条有关。

scroll常见属性
对象名.scrollTop 返回被卷去的上侧距离(被滚动条隐藏的上沿到视口顶部的距离),返回数值不带单位
对象名.scrollLeft ~左~
对象名.scrollWidth 返回自身实际宽度(当内容超出时,也会显示实际大小),不含边框,不带单位
对象名.scrollHeigth ~高~

scroll常见方法
对象名.scroll(x坐标,y坐标)
直接滚动到对象的相应位置。
注意: 里面的数字不加单位!!!

scroll有关的事件: onscroll事件 滚动条发生变化时触发事件。
注意: 元素被卷去的头部是scrollTop;页面被卷去的头部则是window.pageYOffset,页面被卷去的左侧则是window.pageXOffset。(window这两个和滚动条有关的属性只有IE9以上才支持)



动画效果
原理: 通过定时器setInterval()不断移动盒子的位置。
实现步骤:
1. 获取盒子当前位置。
2. 让盒子在当前位置上加上一个移动距离。
3. 利用定时器不断重复这个操作。
4. 加一个结束定时器的条件。
注意: 此元素必须要加定位!!!(若使用translate就不需要定位了)

动画函数简单封装
该函数需要传递两个参数: 动画对象和移动的距离。

缓动动画  元素的运动速度有所变化
原理: 以 (目标值 - 现在的位置) / 10 作为每次移动的步长(可以实现倒退的效果)。
当元素到达目标位置时就停止计时器。
注意: 每次移动的步长若为正数,则需要向上取整,从而避免小数运算;但若步长为负数,则该向下取整。

动画函数添加回调函数
原理: 将函数作为一个参数,传到另一个函数里面,先执行那个函数后,再执行传进去的那个函数,这个过程就是回调。
即在动画函数里面添加一个新的参数,用来传递函数,然后该参数的名字就可以作为函数来使用,一般将其写在定时器结束之后。

定时器一般设置为15毫秒。


动画函数的简单优化(由于函数闭包导致每一个函数栈不被释放,导致大量同名变量)

给不同的元素记录不同的定时器
核心原理: 利用js是一门动态语言,从而方便的给当前对象添加属性。
如function anima(obj, target) {}
由于obj为对象,我们可以给obj添加新的属性,即 obj.timer = setInterval();

但这样还有一个问题,将动画绑定到一个事件中,若反复执行该事件,则会给当前对象添加大量定时器。
需要在动画函数前面先清除一次定时器再添加。


轮播图中的最后一张图无缝衔接第一张图其实是在最后面添加第一张图,当轮播图到最后的位置时,不做动画直接跳转到开始的位置,所以看着像没变一样。
轮播图的自动播放功能,其实就相当于点了一次右侧按钮,所以只需要手动调用右侧按钮的事件即可。
注意: 清除定时器的时候记得将定时器的名称赋值为null,这样安全。

轮播图中的节流阀: 防止轮播图按钮连续点击造成播放过快。
目的: 上一个函数动画执行完后,再去执行下一个函数动画,让事件无法连续触发。
原理: 利用回调函数,添加一个变量来控制,锁住函数和解锁函数。
注意: 一定要有回调函数,在回调函数中来解锁函数!!!


移动端网页特效

触屏事件( 传统方法要加on ) 
1. touchstart 手指触摸到一个DOM元素时触发

2. touchmove 手指在一个DOM元素上滑动时触发

3. touchend 手指从一个DOM元素上移开时触发


触屏事件的事件对象
这是一类描述手指在触摸平面的状态变化事件,用于描述一个或多个触点,使开发者可以检测触点的移动,增加,减少等。

e.touches 正在触摸屏幕的所有手指的一个列表
e.targetTouches 正在触摸当前DOM元素的手指的列表
e.changedTouches 手指状态发生了改变的列表, 从无到有 / 从有到无
同样具有client,screen,page三个属性。

注意: 手指滑动时也会触发屏幕的滚动,所以在移动端拖动元素时要阻止默认的屏幕滚动e.preventDefault()
且移动端的touchmove事件应添加给被拖动的元素自身,而非document。
移动端第一张图片的前面应该补上最后一张,因为拖动的时候会把前面的空白显示出来!!!

若使用translate可以直接使用transition来实现缓动效果,就不需要动画函数了。
若使用transition则需要一个新的事件 transitionend(过渡结束事件)
当滚动到最后一张且过渡效果结束时,我们需要在此时去掉过渡效果,然后立即跳转到第一张。

且在手指拖动时,不需要拖动效果,所以要取消。

在移动端中,click会有300ms的延时,因为移动端屏幕双击会缩放页面!!!
解决方法:
1. 禁用缩放
在<meta>的name="viewport"中的content里面加上 user-scalable=no 即可。

2. 利用touch事件自己封装一个事件来解决延迟
原理: 1.手指触摸屏幕时,记录时间。 2. 当手指离开屏幕时,记录时间。 3. 时间相减,若小于150ms且没有滑动屏幕,即为点击。

3. 使用插件(fastclick)来解决延迟
js插件其实就是js文件,遵循一定的规范编写,方便程序展示效果,拥有特定功能且方便调用。
特点: 一般为了解决某个问题存在,功能单一并且比较小。
fastclick地址: https://github.com/ftlabs/fastclick
js文件在lib文件夹里面。


--------------------------------------------------------------------------------------------
插件:

制作轮播图时,由于js代码实现较为容易复制,可以使用swiper插件,下载地址: https://www.swiper.com.cn/
这个插件可以提供需要的css和js文件,甚至还有与你所想相似的html架构。

引入相应的文件后,html结构,css和js的调用代码可以直接从官网上复制粘贴!!!

移动端还有其他的各种插件,如superslide,iscroll等。

插件使用的方法:
1. 确认插件的功能
2. 去官网查看使用说明
3. 下载插件
4. 打开demo实例文件,查看需要引入的文件并引入
5. 复制相应的html,css,js。
6. 修改对应的样式。
7. 根据需求更改相应的参数即可。


注意:在github中,核心文件一般放在dist文件夹里面。

可以通过插件(zy.media.js)来快速设置视频标签的样式和控制效果。
官网地址: https://github.com/ireaderlab/zyMedia

也可以通过框架来制作轮播图!!!
注意: Bootstrap是基于jQuery来制作的,所以使用Bootstrap来制作轮播图时,要先引入jQuery文件。
使用方法和框架一样。
---------------------------------------------------------------------------------------------

本地数据存储
随着互联网数据的发展,网页越来越强大,为了满足各种各样的需求,会经常在本地存储大量的数据。

本地存储特性
1. 数据存储在用户的浏览器中。
2. 设置,读取方便,甚至页面刷新都不丢失数据。
3. 容量大,sessionStorage大约为5M,localStorage约为20M。
4. 只能存储字符串,可以将对象JSON.stringify(要转化的数据) 编码后存储(重要!!!)。 

注意: 若使用这种方式,取出来的数据也是字符串形式,所以在取出来时还需要将字符串转化为原先的数据。
方法: JSON.parse(取出来的数据)


本地存储可以在调试栏中的Application中的Storage里面找到(edge中位于应用程序)。

window.sessionStorage(会话存储)
特点: 
1. 生命周期为关闭浏览器窗口。
2. 同一个页面下数据可以共享。
3. 以键值对的形式存储使用。

存储数据: sessionStorage.setItem(key, value)
获取数据: sessionStorage.getItem(key)
删除数据(只能删除一个): sessionStorage.removeItem(key)
删除所有数据: sessionStorage.clear()


window.localStorage(本地存储)
特点:
1. 生命周期永久生效,除非手动删除,否则关闭页面也会存在。
2. 可以多窗口页面共享(仅限于同一浏览器内)
3. 以键值对的形式存储使用。

获取删除数据的方式同sessionStorage,只是将sessionStorage改为localStorage。

若有大部分数据需要在本地存储,则应该使用数组的形式进行存储,方便遍历。

change事件: 当用户更改<input>,<select>,<textarea>这些元素的值或者状态时会触发该事件。

-----------------------------------------------------------------------------------------

ES6的模板字符
可以极大提高开发效率!!!
语法规范: `${表达式}`
注意:  ` 为tab键上面那个,且这里面的支持三目运算符。

模板字符拼接字符串
如输出 我老婆是甘雨
则可以这样输出 console.log(`我老婆是${lovers[0]}`)
这样可以省略引号和加号,且这样可以随意换行,之前的那种不能随意换行。

