nodejs是一个应用程序,是一款软件,可以运行js。

nodejs的作用:
1. 开发服务器应用
2. 开发工具类应用

3. 开发桌面端应用
通过框架electron来开发。

nodejs注意事项: nodejs中是不能使用BOM和DOM的API的,只能使用nodejs提供的API。
console和定时器是通用的。

在nodejs中,顶级对象为global,也可以通过globalThis来访问该顶级对象。

__dirname为一个 '全局变量'(且为字符串),该变量所保存的是 所在文件的所在目录的绝对路径 。
在使用fs模块操作文件时一般都是用这种。

__fliename同__dirname,也为一个'全局变量',该变量保存的是 当前文件的绝对路径 。

通过node运行js程序时需要在文件所在目录中打开终端,然后通过 node js文件 来运行js。 

nvm,即用于管理node版本的工具,方便切换不同版本的Node.js

在utf-8中,一个汉字占三个字节。


Buffer
Buffer,即缓冲区,是一个类似于Array的对象(具有一些属性,如length),用于表示固定长度的字节序列,即一段固定长度的内存空间,用于处理二进制数据。

Buffer的性质:
1. Buffer大小固定且无法调整
2. Buffer性能较好,可以直接对计算机内存进行操作
3. Buffer中每个元素的大小为1字节(除非为汉字)

Buffer的创建
1. alloc
语法规范: let 变量名=Buffer.alloc(具体字节,为数字)
用这种方法创建的Buffer每一个二进制位都会归0。

2. allocUnsafe
语法规范同上
用这种方法创建的Buffer可能会包含旧数据,因为其不会清空之前的旧数据。

3. from
语法规范: let变量名=Buffer.from(字符串\数组,字符串编码,如'ascii','uef-8')
里面的字符串会根据unicode编码表转换成数字存储到Buffer里面;数组则是直接根据数据来存储。
而若()里面的为数组,则使用Buffer中的toString方法可以把数组里面的数根据utf-8的编码转换为字符串。


Buffer类似于数组,所以可以通过数组的方式来读取。

注意: Buffer里面每个元素为1字节,即处理数字一共只有8位二进制数,即最大值为255,若数据超出,则会舍去超出的位数。



fsAPI(本接口需要用在集成终端中运行文件,而非直接运行)
fs即file system(文件系统),可以根硬盘进行交互,完成和文件及文件(不止txt)的相关操作。

下面的方法都需要导入fs模块, 即const 变量名=require('fs') ,再通过该变量名调用,一般命名为fs。
注意: const和var,let差不多,只不过表示的是常量,需要初始化和不可修改

在fs中,其相对路径参照的不是运行的代码所在的目录,而是命令行的工作目录。


fs写入文件
语法规范: 前面的变量名.writeFile(file,写入的数据,[选项配置],回调函数)
file为文件 相对/绝对 路径,若找不到,则会在路径中自动创建。
回调参数会被传入一个参数,若写入成功则为null,写入失败则会传入一个错误对象。

该方法为异步方法。
fs的同步写入文件函数为writeFileSync(),其参数和writeFile大体一致,除了无回调函数。

若想使用writeFile追加写入文件,则需要在选项配置那里加上{flag: 'a'}即可。


fs追加写入(若想多次写入,使用该方法)
appendFile()
其参数和writeFile一致,调用方法也一致。

同理,上述为异步写入方法,同步写入方法为appendFileSync(),返回读取的数据。

注意: 写入和追加写入时都支持转义字符。


fs文件读取
readFile() 
参数相较于writeFlie()只少了data,因为不需要数据写入。
其回调函数有两个参数err,data。
err和写入时一样,data则为读取的数据,可以直接log输出。

读取的内容为Buffer,需要用到Buffer的toString()方法,()里面为编码的方式,一般为utf-8,需加''。
注意: 若toString()不写编码方式,则无法输出;若读取的文件为视频等其他,则toString转换的信息为乱码(因为不为文字)。

同理,上述为异步方法,同步方法为~Sync() 不需要接收回调函数


fs流式写入(适合写入频率较高的文件或大文件)
1. 创建写入流对象
语法规范: const/var/let 变量名=fs.creatWriteStream('文件路径');

2. 创建了写入流对象以后,就可以通过上述变量的 write('写入内容') 方法来写入文件。
3. 关闭该通道(可有可无,在程序运行结束后自动会关闭)
语法规范: 写入流对象.close()

其实文件下载,软件安装,程序日志的编写其实都用到了文件的写入。
注意: 但需要持久性的保存数据时,才会用到文件写入。


fs流式读取(为一块一块地读取,用于读取和处理大文件)
1. 创建读取流对象
语法规范: const/var/let 变量名=fs.creatReadStream('文件路径');

2. 绑定一个data事件
语法规范: rs.on('data',chunk=> console.log(chunk))
chunk为回调函数的形参,可以改名,且输出的数据为Buffer,一次读取至多64KB的数据。

3. 在读取完以后,其还会触发end事件(自动触发,可以手动改写)
语法规范: rs.on('end',无参数回调函数)

若想通过 读取写入流 快速复制文件,只需要 写入流对象.pipe(读取流对象) 即可。


fs重命名并文件
rename(旧路径,改名后的新路径,err回调函数)
该方法中的err和写文件的err一样,且会重命名加移动文件。

同理,该方法为异步方法,同步方法为~Sync() ,无回调函数。


fs删除文件
1. unlink(删除的文件路径,err回调函数)
该方法中的err和写文件的err一样。

2. rm()
参数同上,但该方法可以删除文件夹,参数同下。

上面方法为异步方法,同步方法为~Sync() ,无回调函数。


fs文件夹操作
创建文件夹
mkdir(文件夹路径,[选项配置],err回调函数)
该方法中的err和读写文件的err一样。

若想递归创建,则选项配置里需加上{recursive: true},这样就可以一次创建多级目录。


文件夹读取
readdir(文件夹路径,err及data回调函数)
err及data回调函数和读取文件的回调函数一致,若文件夹路径为 ./ ， 则表示读取当前文件夹。

读取的data为数组,里面存储的是文件夹里面文件的名称。


文件夹删除
rmdir(文件夹路径,[选项配置],err回调函数)
该方法中的err和写文件的err一样。
注意: 若无选项配置,则该方法无法删除非空文件夹。

若想递归删除,则选项配置里需加上{recursive: true},这样就可以一次全部删除。


查看资源状态
stat(文件路径,err及data回调函数)
err及data回调函数和读取文件的回调函数一致。

其中的data有两个方法isFile(),isDirectory(),分别判断其是否为文件,文件夹,返回bool值。



path模块
该模块主要用来操作路径。

同样,在使用时,需要先导入path模块,导入方式同fs,一般命名为path。

拼接绝对路径(常用,linux中文件的分隔符为/)
resolve(当前目录的绝对路径一般为__dirname,文件相对于当前目录的路径)
该方法会把这两个路径拼接,形成规范的绝对路径


解析路径并返回对象
parse(文件路径)
该方法会返回当前文件的根目录,绝对路径,后缀名,文件名。



IP地址
IP地址本身就是一个数字标识,为一个32位的二进制数字,每8位一组,将每组转换成十进制以后,每组之间用 . 分隔,就形成了IPV4的地址,如192.168.1.3。

IP用于标识网络中的设备,实现设备之间的通信。

IP地址分为两类: 公网IP,私网IP,本地回环IP。
私网IP,也叫局域网IP,由于IPV4不够的缘故,所以只能把同时连接到一台路由器上的设备共享一个IP地址(也就是公网IP)。而路由器分配给每个设备的IP,就叫做私网IP,私网IP无法直接访问互联网。
192.168.0.0~192.168.255.255(使用较多)都属于私网IP。

公网IP,也叫广域网IP,可以直接访问互联网。
本地回环地址IP, 即 127.0.0.1~127.255.255.254,用设备访问这些IP地址都只能访问自身。


端口,即应用程序的数字标识,一台计算机一共有65536个端口(0~65535),一个应用程序可以使用一个或多个端口。
端口可以实现不同主机应用程序之间的通讯。


http(超文本传输协议,目前互联网应用最广泛的协议之一)
http对浏览器和服务器进行了约束。

浏览器向服务器发送的数据称之为请求,数据内容为请求报文;而浏览器给服务器返回的数据称之为响应,数据内容称之为响应报文。


http报文
实际上请求和响应报文本质上是字符串。

请求报文的结构
1. 请求行
即报文的第一行。
请求行一共由三部分组成: 请求方法,URL和http协议的版本号。
(1) 请求方法一共有四个: GET(用于获取数据), POST(用于提交数据), PUT/PATCH(用于更新数据),DELETE(用于删除数据)
GET和POST用的最多,上述用途都是主要用途,不一定。

POST主要出现在form标签中的method为post和ajax的post请求。

POST和GET的区别
1. GET请求一般将参数放到URL后面,而POST请求则是将参数放到请求体当中(非绝对)
2. POST请求相对于GET安全一些,因为GET会将参数暴露在地址栏(被抓包后都会暴露)
3. GET请求有大小限制,一般为2K,POST则无大小限制

(2) URL,又叫统一资源定位符,也是一个字符串
URL由 协议名,主机名(可为域名或IP地址,可以定位网络中的计算机),端口号(有时可省略),路径(用于定位资源,用?与后面分隔),查询字符串(由字符串的键值对组成, &分隔,为对资源的描述)

其中路径分为相对路径和绝对路径,前面为 / 属于绝对路径,其会和当前网页除去路径和查找字符串的url拼接到一起再发送请求;若不写协议名,则会和当前web的协议名拼接到一起再发送请求。
./ 属于相对路径(参照当前路径),若到达根目录后仍去寻找上一级目录,则不会移动,也不会报错。

(3)http版本号,没什么好了解的。

2. 请求头
即报文的第二行到一个空行之前,称之为请求头。
由一系列的键值对组成,即 键: 值

3. 请求体
空行的后面的内容称之为请求体,内容格式及其灵活,可以设置任意内容。


响应报文的结构
与请求报文一致,分为响应行,响应头,响应体;响应体和响应体之间也存在空行。

(1) 响应行
响应行由http版本号,响应状态码,响应状态的描述组成。

响应状态码常见的有4个: 200(请求成功,描述为OK),403(禁止请求,描述为Forbidden),404(找不到资源,Not Found),500(服务器内部错误,Internal Server Error)。
其可以分类为由1,2,3,4,5开头的状态码:
1xx: 信息响应
2xx；成功响应
3xx: 重定向消息
4xx: 客户端错误响应
5xx: 服务端错误响应

(2) 响应头
也由一系列键值对组成

(3) 响应体
响应体的内容格式也非常灵活,常见的响应体格式有: html,css,js,图片,视频,JSON。
所以,要想发送网页,只需要将http的内容设置在响应体里面即可。


创建http服务
创建http服务,首先就要导入http模块,导入方式同fs,一般命名为http。

1. 创建服务对象
语法规范: const 变量名=http.creatServer()
这里的creatServer()可以接收一个实参,为回调函数,该函数有request和response两个形参,其中分别是封装了请求报文和响应报文的对象。
该函数会在接收到http请求后就会执行。


2. 监听端口,启动服务
语法规范: 服务对象.listen(端口号,回调函数)
回调函数会于服务启动成功后执行,无参数。

启动成功后,可以通过浏览器输入 本地回环IP+相应的端口号 来直接访问该服务器程序了。
在终端中输入 crtl+c 可以关闭服务。
在响应体中,如果有中文,会出现乱码,需要设置响应头中解决。

http协议的默认端口是80,https协议的默认端口为443,http服务开发常用端口有3000,8080,9000等。
使用协议的默认端口时,不需要端口号也能向服务器发送请求。


获取http请求报文(为request的方法和属性)
1. 请求方法
语法规范: request.method
获取http请求的请求方法,所有字母均大写!!!

2. 请求路径
语法规范: request.url
该属性只能获取路径以及查询字符串,无法获取url中的域名以及协议的内容。

3. 请求头
语法规范: request.header
为一个对象,所以若只想单独获取其中的一个值时,只需要在后面 .对应的属性名 即可


获取请求体
1. 声明一个变量为空字符串
2. 给request绑定一个data事件
request.on('data',chunk=>{
    上面的变量+=chunk;
})
这个chunk本质上是一个Buffer,在进行上述运算时会自动转换为字符串。

3. 给request绑定一个end事件,当可读流触发完以后便会触发该事件 
request.on('end',()=>{
    输出上面的变量
})
当请求方法为POST时就可以看到请求体了。


设置http响应报文(为response方法和属性)
1. 设置响应状态码
statusCode(默认为200)
语法规范: respond.statusCode = 数字

2. 设置响应状态的描述(很少用)
statusMessage
语法规范: respond.statusMessage=字符串

3. 设置响应头信息
setHeader('头名',头值)
可以用来写自定义的响应头。
setHeader('content-type','{mime类型};charset=utf-8') 可以解决响应体中中文乱码的问题,但仅限于html。
html不需要这句话也不会乱码,因为其meta标签已经设置好了,但响应头的优先级会更高!!!


4. 设置响应体
write('xx') / end('xx')
write('xx')也可以设置响应体,且可以多次调用。
end('xx') 该方法可以设置响应体,并结束响应,不能多次调用,每次执行回调函数时必须有且只有一个。
如果在write中设置了响应体,那么在end里面就不设置了。
设置响应体时传输的数据可以是Buffer,所以在fs读写文件时不需要进行转换。

注意: 但在响应体里面设置html等代码时,方法所用的需变为反引号(tab上面那个),可以通过fs来读写文件来设置响应体(重要!!!)。

网络资源加载的基本过程
不是一次请求,而是发送多个请求,分别请求html,图片,css等资源,且是并行请求。


URL对象,其中包含了协议名,密码,端口号文件路径等信息,便于我们获取请求的url。
构造方法: new URL('文件路径','协议名+网站名') / new URL('包含所有的网站名')
若想获取URL中的查询字符串,不能直接通过属性访问,而是通过其相应属性中的get方法来访问,即 url.searchParams.get('名')


当浏览器请求多个文件时,我们需要根据请求头url(可以通过request.url来获取),来区分请求并返回不同的文件。
由于request.url返回的是url对象(直接使用url的话css会失效),所以我们要这样, let {pathname}=new URL(request.url ,'协议名+网站名'),通过pathname来判断请求的文件。
注意: 若为html文件,则为 / ,其他的,则为 /+ html中的路径。
为了简化代码,只需要拼接__dirname和pathname即可,这样就可以省去大量的if-else。

静态资源和动态资源
静态资源是指内容长时间不发生改变的资源,如图片,视频,css等文件。
动态资源是指内容经常更新的资源,比如部分图片,搜索列表页面等。

http服务在哪个文件夹中寻找静态资源,哪个文件夹就是静态资源目录,也称之为网站根目录。
vscode中live-server的网站根目录就是当前vscode所打开的文件夹。


mime类型
mime类型,即媒体类型,是一种标准,用来表示文档,文件或字节流的性质和格式。
类型结构: [主类形]/[子类型]

在http服务中,我们可以通过设置响应头content-type来表明响应体的类型。
若为文本,则为 text/文件后缀 ,html,css,js都属于该类型。
若为视频,则为 video/文件后缀 ;若为图片,则为 image/文件后缀。

对于未知的类型,可以选择 application/octet-stream 类型,浏览器会对该响应体内容进行独立存储,也就是常见的下载系统。



模块化
将一个复杂的程序文件按照一定的规则拆分成多个文件的过程称之为模块化。
其中拆分出的每个文件就是一个模块,模块内部的数据是私有的,不过模块可以暴露内部数据使其他内部数据便于使用。

模块化项目在编码时是模块一个一个编码的。
模块化可以防止命名冲突,且程序高复用性,具有高维护性。

导入模块的方式和导入fs的方式一致,要先导入,才能使用其暴露的数据。
导入时,对于自己创建的模块,导入路径建议为相对路径,且不能省略 ./ 和 ../ ; nodejs内置模块则不需要 ./ 和 ../。

导入时,js和JSON文件可以不用写后缀,c/c++编写的node扩展文件也可以不写后缀(一般用不到)。
当js和JSON同名时,若不写后缀,则优先导入js文件;若导入其他类型的文件,会以js文件进行处理。


require导入自定义模块的流程
1. 相对路径转绝对路径
2. 缓存检测(查看之前是否加载过这个文件)
3. 读取文件代码
4. 包裹为一个函数并执行(可以通过arguments.callee.toString()得到该函数)
5. 缓存结果
6. 返回module.exports的值


模块暴露数据
模块暴露数据的方式有两种:
1. module.exports=value
2. exports.name=value

module.exports可以暴露任意的数据;方法2中的name为暴露出去的值的名称,可自定义。
若想同时暴露多个数据,可以暴露一个将所有数据汇集起来的对象;若只暴露了一个函数,则函数的调用名为require所赋予的变量名。

注意: 不能使用exports=value的形式暴露数据,因为exports和module之间存在 exports=module.exports={}
且require暴露的是module.exports的值,所以不能使用。


导入文件夹
如果require导入的路径是一个文件夹,其会先检测文件夹下是否存在 package.json文件中main属性所对应的文件 ,存在即导入,不存在就会报错。
若main属性不存在或者package.json不存在,则会尝试导入文件夹下的 index.js/index.json 若未找到就会报错。



包(来自大佬所写)
包是一组特定工具的源码集合;而包管理工具,就是管理包的软件,可以对包进行下载安装,更新等操作。

常用的包管理工具: npm(最重要),yarn,cnpm。

npm为nodejs官方内置的包管理工具,且会在nodejs安装时自动安装。

npm初始化包,只需要在一个文件夹中打开终端,并运行npm init命令,并选择一系列选项即可。
注意: 包名不能为中文,大写,默认为文件夹的名称,所以文件夹名称也不能使用中文和大写;version要求以 x.x.x 的形式定义,x为数字。

package.json也可以手动创建。
使用npm --yes可以快速创建一个包。


npm安装其他包
其他包一般在网站当中去搜索,网址为 https://www.npmjs.com/

npm安装包只需要在已经初始化的包中打开终端,然后输入 npm i 包名[@指定版本] 即可下载,若包含[],则表示安装指定版本的包。
在安装时可以设置包 在开发和生产阶段(命令为 npm i -S 包名,为默认选项) 或 只在开发阶段使用(命令为 npm i -D 包名)。

因为在把项目上传到github时,我们不会将依赖包上传(防止过大),这时其他人克隆仓库时可以通过 npm i 命令一键安装所有依赖包。

安装网上中的包以后,安装的包就是我们所创建的包的一个依赖包,也可以称之为 所创建的包 依赖于下载的包。

在包中使用网上下载的包时只需要像导入node内置包导入即可,不需要写路径(这样是最好的,因为若当前目录下找不到,则会自动向上寻找,直至磁盘根目录)。

上述安装方法安装的包只能在局部包内使用,不能在文件夹外使用,这种安装叫做局部安装。
我们可以选择全局安装,即不受工作目录影响,即通过 npm i -g 包名 ,也不需要通过require来导入。
可以通过 npm root -g 来查看全局安装的包的所在目录。

通过全局安装安装nodemon后可以在命令行的任何位置运行nodemon命令,通过nodemon来运行js文件时,只要js文件发生变化,node服务就会自动重启。


npm删除包
通过 npm r 包名 可以在局部删除对应的包, npm r -g 包名  可以在全局删除对应的包。


npm配置命令别名
配置命令别名可以更加简单地执行命令,也就是配置package.json中的scripts属性。

配置好相应的命令以后,只需要使用 npm run 对应的别名 即可。
注意: 若命令别名为start,则可以省略run运行,一般用于启动项目;且npm run有自动寻找上级目录的特性。


cnpm
cnpm是淘宝构建的一个 npmjs.com 的一个完整镜像,也叫淘宝镜像,网址: https://npmmirror.com/
cnpm部署在国内,可以大大提升npm包的下载速度。

cnpm提供了一个全局工具包,操作命令和npm大致相同。

或者,我们也可以使用npm去配置淘宝镜像,通过工具配置来使npm配置为cnmp。
只需要通过npm全局安装nrm,通过 nrm ls 可以查看能够使用的仓库,只需要通过 nrm use 仓库名 即可更改下载的仓库。
通过npm config list 可以查看当前使用的仓库地址。


yarn
下载速度是上述管理工具中最快的,通过npm下载即可。

npm和yarn的选择主要是看公司项目的代码,若锁文件的为yarn.lock,则为yarn;若为package-lock.json,则为npm。
个人项目的话看个人喜欢即可。

注意: 包管理工具不要混合使用,否则可能会出现意外(重要!!!)

发表npm包时需要把镜像改为官方镜像(重要!!!)



express框架
express是一个web应用开发框架,也就是一个封装好的工具包,便于开发web应用。

express需要借助npm来进行安装,其包名就为express。

使用express时需要在导入后再创建一个应用对象,一般命名为app。
express在提供http服务时也要用到app.listen方法来监听端口。


路由
路由确定了应用程序如何相应客户端对特定端点的请求。

一个路由由三部分组成: 请求方法,路径和回调函数。
express提供了一系列的方法,可以很方便的使用路由。
语法规范: app.<请求方法,全小写>(路径,回调函数)
这里<>是不写的,即 app.get ,若请求方法为all,则表示所有的请求方法都可以访问;这里的回调函数类似于http的回调函数。
若路径为'*',则表示所有的路径,用来做404响应(写在最后)。


express提取请求报文
express模块兼容以前http模块的写法。

express的独有请求方法
path(类似于之前获取的pathname),query(获取查询字符串,为一个对象,其键值对为对象的属性和属性值),ip(获取客户端的ip地址)

get('头名') 可以获取到请求头的值。


express获取路由参数
路由参数,即URL路径中的参数。

在使用路由的方法中可以使用占位符,如app.get('/:id.html'),这个 :id 就表示占位符。
在express中,可以使用请求中的 params.和上面占位符一样的名字(除去:) 属性来获取上述占位符的具体信息。


express的响应设置
同理,其兼容原生http模块的写法。

express的独有响应方法
status(响应码,为数字), set('头名',头值) 设置响应头, send('响应体') 设置响应体,并结束响应。
注意: 以上方法支持链式操作,即 res.status().set().send()

下面的方法不能和end()混用,否则会失效!!!
1. redirect('url') 跳转相应,也叫重定向
当访问路由对应的路径时,会直接跳转到对应的网页,同时结束响应。

2. download(文件路径) 下载响应
当访问路由对应的路径时,会直接把所返回的附件下载,并结束响应。

3. json(JSON格式) json响应
当访问路由对应的路径时,会自动设置json的mime类型,并结束响应。

4. sendFile(文件路径) 可以直接响应文件
当访问路由对应的路径时,会响应对应的文件,并结束响应。


中间件
其在本质上为回调函数,也称之为中间件函数,可以像路由的回调函数一样访问请求对象,响应对象。
中间件的作用是可以使用函数进行封装公共操作,从而简化代码。

中间件分为全局中间件和路由中间件。
全局中间件就是只要有请求发送到服务端,全局中间件的函数就会执行。
而路由中间件是只有当请求满足一定的规则的时候,路由中间件的函数才会执行。

全局中间件的使用方式:
1. 声明中间件函数
function 函数名(req,res,next) {
    函数体;
    next();  //一定要有,否则会报错!!!
}
其中req,res分别表示请求和响应,next则表示路由回调函数。
2. 使用中间件函数
express应用对象名.use(中间函数名)

这样就已经应用了全局中间件了。


局部中间件函数的声明和全局中间件函数的声明一致,但使用时要把该函数放在要使用的路由后面。
即 app.get(路径,局部中间件函数,req res回调函数),这里的局部中间件函数不需要()。

遇到对应的请求后,就会先执行局部中间件函数,若满足,则会继续执行后面的回调函数,若不满足,则会执行局部中间件的语句。


静态资源中间件的使用
即 app.use(express.static(文件夹路径)), 该中间件还会自动为我们设置content-type。
当浏览器发送请求之后,服务器就会根据静态资源中间件到该文件夹中再根据路径读取文件,然后响应相应内容,并结束响应,就不需要再去编辑有关静态资源的路由了。
注意: 这里的文件夹路径需要为绝对路径,否则会报错。

注意: 在使用静态资源中间件时,index.html时默认打开的资源;且若静态资源和路由规则同时匹配,那么谁先匹配谁相应(看代码的先后顺序)。
在开发中,路由一般响应动态资源,而静态资源中间件用来响应静态资源。
该方法只能访问包内部的文件夹,不能访问包外部的(重要!!!)


express获取请求体数据 body-parser
express可以使用body-parser包来处理请求体,body-parser需要通过npm来安装。

使用方法:
1. 导包
2. 将其作为路由中间件处理
var jsonParser = bodyParser.json() //解析JSON格式的请求体的中间件
var urlencodedParser = bodyParser.urlencoded({ extended: false }) //解析querystring格式请求体的中间件

3. 正确解析请求体以后,就可以通过 req(即请求).body 获取请求体的内容了
返回的是一个对象,其属性名为表单中的name,属性值为输入的内容。


防盗链
防盗链,即防止外部网址盗用本站资源,可以禁止除了指定域名外的其他网站使用该资源。
防盗链是通过请求头中的referer来实现的,所以要想实现防盗效果,只需要创建一个全局中间件函数,在里面检测referer的值即可。


路由模块化
需要在额外的文件中去创建路由对象, 即const router=express.Router()。
这里的router其实就相当于上述的app,在创建完router的路由后,只需要通过 module.exports=router 暴露即可。

通过require导入对应的路由后,只需要在主文件中 app.use([路由前缀 类似于路径],模块所赋予的变量) 即可。
路由前缀会给对应模块里面的路由路径在前面添加路由前缀,这样就不需要再更改模块路由里面的路由路径。


模板引擎
模板引擎是分离用户界面和应用数据的一种通用型技术,EJS就是一个高效的javascript的模板引擎,用来分离html和js(特指服务端的js)的。

在使用EJS时,首先需要下载ejs,也是用npm进行下载。
导入ejs的包所赋予的变量一般命名为ejs。

ejs的用法其实也就是jsp的写法,目前已经被优化了。


ejs列表渲染
ejs.render(`需要拼接的语句`,包含里面的变量所对应的值的对象)
在该方法中,变量要用<%= %>包括起来,render的第二个参数的中属性名要和第一个参数的中的变量名一致,属性值要和js中对应的变量名同名,若属性名和属性值相等可以只写属性名。

在需要拼接的语句中,同样可以使用循环
语法规范: <% 需要遍历的数组.forEach(item =>{ %> 重复拼接的内容 <% } )>


ejs条件渲染
同样,在render中使用
语法规范: <% if(condition){ %> 条件为真输出内容 <%}else{ %> 条件为假的内容<% } %>


express中使用ejs
1. 在express中使用ejs时,需要给应用对象设置模板引擎,即 app.set('view engine','ejs') 
2. 给应用对象设置模板文件(即具有模板语法性质的文件)的存放位置,即 app.set('views',文件路径)
3. 在存放位置中创建模板文件,后缀需为ejs
4. 通过res.render('后缀为ejs的文件名',对应属性的对象)来响应请求并结束响应。


express-generator
express-generator应用生成器工具可以快速创建一个应用的骨架。
需要用到npm的全局安装来安装该包名(就是express-generator)

安装后,可以通过 express -h来查看可用的操作。

这时,通过express -e 文件夹名称 可以在当前目录下创建该文件夹及其相应的骨架。
在文件夹中,由于对应的包还没下载,需要通过 npm i 一键下载。

在该文件夹中,实际运行的文件为bin中的www.js文件,但我们可以通过npm start直接运行(json已经设置好了),端口使用的是3000。


文件上传报文
文件上传其实也是发送http请求报文,同样express中也可以去批量处理文件的上传。

express处理需要用上额外的包formidable,通过npm下载。
具体操作和前面的大致一样,具体代码直接去复制粘贴即可。
文件上传并保存到服务器以后,需要服务器保存该文件的url,可以通过files的newFilename来获取文件名。


lowdb
该包是借助于JSON文件来实现数据库的功能,通过npm下载。
通过npm上的官网示例进行使用。

















